{"type":"data","nodes":[null,{"type":"data","data":[{"title":1,"summary":2,"formattedDate":3,"content":4,"tags":5},"🏅 프로그래머스 12985 : 예상 대진표 - Javascript","프로그래머스 12985 : 예상 대진표 문제를 Javascript로 풀이한 내용입니다.","2023-02-25","\u003Ch2 >문제 설명\u003C/h2> \u003Cul >\u003Cli>출처: \u003Ca href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12985\" rel=\"noopener noreferrer\" target=\"_blank\">프로그래머스 12985 : 예상 대진표\u003C/a>\u003C/li>\u003C/ul> \u003Cp >△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, … , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다.\u003C/p> \u003Cp >이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. \u003Cstrong>단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.\u003C/strong>\u003C/p> \u003Chr> \u003Ch2 >제한사항\u003C/h2> \u003Cul >\u003Cli>N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.)\u003C/li> \u003Cli>A, B : N 이하인 자연수 (단, A ≠ B 입니다.)\u003C/li>\u003C/ul> \u003Chr> \u003Ch2 >입출력 예\u003C/h2> \u003Ctable >\u003Cthead>\u003Ctr>\u003Cth align=\"left\">N\u003C/th> \u003Cth align=\"left\">A\u003C/th> \u003Cth align=\"left\">B\u003C/th>\u003C/tr>\u003C/thead> \u003Ctbody>\u003Ctr>\u003Ctd align=\"left\">8\u003C/td> \u003Ctd align=\"left\">4\u003C/td> \u003Ctd align=\"left\">7\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table> \u003Cul >\u003Cli>예제 #1\n첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다.\u003C/li>\u003C/ul> \u003Chr> \u003Ch2 >풀이 과정 - 시도 1 : 실제로 라운드 진행 (성공)\u003C/h2> \u003Cp >가장 단순하게 주어진대로 모든 라운드를 직접 진행해 결과를 찾는 방식으로 구현했습니다.\n굉장히 비효율적이지만 실제로 잘 작동하고, 테스트 케이스도 모두 통과했습니다.\u003C/p> \u003Cpre class=\"language-javascript\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-javascript\">\u003Cspan class=\"token keyword\">function\u003C/span> \u003Cspan class=\"token function\">solution\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token parameter\">n\u003Cspan class=\"token punctuation\">,\u003C/span> a\u003Cspan class=\"token punctuation\">,\u003C/span> b\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n  \u003Cspan class=\"token comment\">//대진표 작성\u003C/span>\n  \u003Cspan class=\"token comment\">//a와 b는 1, 나머지는 0으로 저장\u003C/span>\n  \u003Cspan class=\"token keyword\">const\u003C/span> table \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token keyword\">for\u003C/span> \u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token keyword\">let\u003C/span> i \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token number\">0\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span> i \u003Cspan class=\"token operator\">&lt;\u003C/span> n\u003Cspan class=\"token punctuation\">;\u003C/span> \u003Cspan class=\"token operator\">++\u003C/span>i\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n    table\u003Cspan class=\"token punctuation\">[\u003C/span>i\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token function\">Number\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>a \u003Cspan class=\"token operator\">-\u003C/span> \u003Cspan class=\"token number\">1\u003C/span> \u003Cspan class=\"token operator\">===\u003C/span> i \u003Cspan class=\"token operator\">||\u003C/span> b \u003Cspan class=\"token operator\">-\u003C/span> \u003Cspan class=\"token number\">1\u003C/span> \u003Cspan class=\"token operator\">===\u003C/span> i\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token punctuation\">&#125;\u003C/span>\n\n  \u003Cspan class=\"token comment\">//0부터 n까지의 대진표를 순회한 후 n을 반으로 나누며 반복 진행\u003C/span>\n  \u003Cspan class=\"token keyword\">let\u003C/span> round \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token number\">0\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token keyword\">for\u003C/span> \u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token keyword\">let\u003C/span> i \u003Cspan class=\"token operator\">=\u003C/span> n\u003Cspan class=\"token punctuation\">;\u003C/span> n \u003Cspan class=\"token operator\">>\u003C/span> \u003Cspan class=\"token number\">1\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span> n \u003Cspan class=\"token operator\">/=\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n    round\u003Cspan class=\"token operator\">++\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n\n    \u003Cspan class=\"token comment\">//라운드 결과는 덧셈으로 간단하게 계산\u003C/span>\n    \u003Cspan class=\"token keyword\">for\u003C/span> \u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token keyword\">let\u003C/span> j \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token number\">0\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span> j \u003Cspan class=\"token operator\">&lt;\u003C/span> n\u003Cspan class=\"token punctuation\">;\u003C/span> j \u003Cspan class=\"token operator\">+=\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n      table\u003Cspan class=\"token punctuation\">[\u003C/span>j \u003Cspan class=\"token operator\">/\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token operator\">=\u003C/span> table\u003Cspan class=\"token punctuation\">[\u003C/span>j\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token operator\">+\u003C/span> table\u003Cspan class=\"token punctuation\">[\u003C/span>j \u003Cspan class=\"token operator\">+\u003C/span> \u003Cspan class=\"token number\">1\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n\n      \u003Cspan class=\"token comment\">//라운드 결과가 2인 경우 a와 b가 만난 것이므로 라운드를 반환\u003C/span>\n      \u003Cspan class=\"token keyword\">if\u003C/span> \u003Cspan class=\"token punctuation\">(\u003C/span>table\u003Cspan class=\"token punctuation\">[\u003C/span>j \u003Cspan class=\"token operator\">/\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token operator\">===\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n        \u003Cspan class=\"token keyword\">return\u003C/span> round\u003Cspan class=\"token punctuation\">;\u003C/span>\n      \u003Cspan class=\"token punctuation\">&#125;\u003C/span>\n    \u003Cspan class=\"token punctuation\">&#125;\u003C/span>\n  \u003Cspan class=\"token punctuation\">&#125;\u003C/span>\n\u003Cspan class=\"token punctuation\">&#125;\u003C/span>\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cdiv class=\"admonition admonition-info\">\u003Cdiv class=\"admonition-heading\">\u003Ch5>\u003Cspan class=\"admonition-icon\" >\u003Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\u003Cpath class=\"outlined\" d=\"M12,8v0m0,3v5m0-13a9,9 0,1 1-.1,0\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"math math-inline\">\u003C!-- HTML_TAG_START -->\u003Cspan class=\"katex\">\u003Cspan class=\"katex-mathml\">\u003Cmath xmlns=\"http://www.w3.org/1998/Math/MathML\">\u003Csemantics>\u003Cmrow>\u003Cmi>n\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>8\u003C/mn>\u003Cmo separator=\"true\">,\u003C/mo>\u003Cmi>a\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>4\u003C/mn>\u003Cmo separator=\"true\">,\u003C/mo>\u003Cmi>b\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>7\u003C/mn>\u003C/mrow>\u003Cannotation encoding=\"application/x-tex\">n=8, a=4, b=7\u003C/annotation>\u003C/semantics>\u003C/math>\u003C/span>\u003Cspan class=\"katex-html\" aria-hidden=\"true\">\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.4306em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">n\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\">\u003C/span>\u003Cspan class=\"mord\">8\u003C/span>\u003Cspan class=\"mpunct\">,\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.1667em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">a\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\">\u003C/span>\u003Cspan class=\"mord\">4\u003C/span>\u003Cspan class=\"mpunct\">,\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.1667em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">b\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.6444em;\">\u003C/span>\u003Cspan class=\"mord\">7\u003C/span>\u003C/span>\u003C/span>\u003C/span>\u003C!-- HTML_TAG_END -->\u003C/span> 의 경우 진행 방식\u003C/h5>\u003C/div>\u003Cdiv class=\"admonition-content\" >\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth align=\"center\">round\u003C/th> \u003Cth align=\"center\">table\u003C/th> \u003Cth align=\"center\">설명\u003C/th>\u003C/tr>\u003C/thead> \u003Ctbody>\u003Ctr>\u003Ctd align=\"center\">0\u003C/td> \u003Ctd align=\"center\">[0, 0, 0, 1, 0, 0, 1, 0]\u003C/td> \u003Ctd align=\"center\">\u003Ccode>table\u003C/code> 배열 생성\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">1\u003C/td> \u003Ctd align=\"center\">[0, 1, 0, 1]\u003C/td> \u003Ctd align=\"center\">라운드 진행\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">2\u003C/td> \u003Ctd align=\"center\">[1, 1]\u003C/td> \u003Ctd align=\"center\">라운드 진행\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">\u003Cstrong>3\u003C/strong>\u003C/td> \u003Ctd align=\"center\">[2]\u003C/td> \u003Ctd align=\"center\">\u003Cstrong>2가 되어 \u003Ccode>round\u003C/code> 반환\u003C/strong>\u003C/td>\u003C/tr>\u003C/tbody> \u003C/table>\u003Cp>(table 배열의 1은 각각 a와 b를 의미합니다)\u003C/p>\u003C/div>\u003C/div> \u003Chr> \u003Ch2 >풀이 과정 - 시도 2 : A와 B를 2로 나누며 비교\u003C/h2> \u003Cp >시도 1의 방식에서는 라운드가 진행 될 때마다 배열이 반으로 줄어들긴 하지만 의미없는 0값들에 대한 연산이 반복되기 때문에 굉장히 비효율적입니다.\n사실상 모든 0은 의미가 없는 값이기 때문에 배열없이 효율적으로 a와 b만 이용해 라운드 값을 찾을 방법을 고민해봤습니다.\u003C/p> \u003Cp >먼저 시도1에서 a와 b가 포함되지 않은 모든 라운드 계산이 의미가 없기 때문에 생략할 필요가 있습니다. 이를 위해 a와 b가 어떻게 이동하는지를 파악해보면 아래와 같습니다.\u003C/p> \u003Cdiv class=\"admonition admonition-info\">\u003Cdiv class=\"admonition-heading\">\u003Ch5>\u003Cspan class=\"admonition-icon\" >\u003Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\u003Cpath class=\"outlined\" d=\"M12,8v0m0,3v5m0-13a9,9 0,1 1-.1,0\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"math math-inline\">\u003C!-- HTML_TAG_START -->\u003Cspan class=\"katex\">\u003Cspan class=\"katex-mathml\">\u003Cmath xmlns=\"http://www.w3.org/1998/Math/MathML\">\u003Csemantics>\u003Cmrow>\u003Cmi>n\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>8\u003C/mn>\u003Cmo separator=\"true\">,\u003C/mo>\u003Cmi>a\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>4\u003C/mn>\u003Cmo separator=\"true\">,\u003C/mo>\u003Cmi>b\u003C/mi>\u003Cmo>=\u003C/mo>\u003Cmn>7\u003C/mn>\u003C/mrow>\u003Cannotation encoding=\"application/x-tex\">n=8, a=4, b=7\u003C/annotation>\u003C/semantics>\u003C/math>\u003C/span>\u003Cspan class=\"katex-html\" aria-hidden=\"true\">\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.4306em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">n\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\">\u003C/span>\u003Cspan class=\"mord\">8\u003C/span>\u003Cspan class=\"mpunct\">,\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.1667em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">a\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\">\u003C/span>\u003Cspan class=\"mord\">4\u003C/span>\u003Cspan class=\"mpunct\">,\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.1667em;\">\u003C/span>\u003Cspan class=\"mord mathnormal\">b\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003Cspan class=\"mrel\">=\u003C/span>\u003Cspan class=\"mspace\" style=\"margin-right:0.2778em;\">\u003C/span>\u003C/span>\u003Cspan class=\"base\">\u003Cspan class=\"strut\" style=\"height:0.6444em;\">\u003C/span>\u003Cspan class=\"mord\">7\u003C/span>\u003C/span>\u003C/span>\u003C/span>\u003C!-- HTML_TAG_END -->\u003C/span> 의 경우 a와 b의 인덱스 변화\u003C/h5>\u003C/div>\u003Cdiv class=\"admonition-content\" >\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth align=\"center\">round\u003C/th> \u003Cth align=\"center\">a\u003C/th> \u003Cth align=\"center\">b\u003C/th>\u003C/tr>\u003C/thead> \u003Ctbody>\u003Ctr>\u003Ctd align=\"center\">0\u003C/td> \u003Ctd align=\"center\">3 (4번째 선수)\u003C/td> \u003Ctd align=\"center\">6 (7번째 선수)\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">1\u003C/td> \u003Ctd align=\"center\">1 (2번째 선수)\u003C/td> \u003Ctd align=\"center\">3 (4번째 선수)\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">2\u003C/td> \u003Ctd align=\"center\">0 (1번째 선수)\u003C/td> \u003Ctd align=\"center\">1 (2번째 선수)\u003C/td>\u003C/tr> \u003Ctr>\u003Ctd align=\"center\">\u003Cstrong>3\u003C/strong>\u003C/td> \u003Ctd align=\"center\">\u003Cstrong>0 (1번째 선수)\u003C/strong>\u003C/td> \u003Ctd align=\"center\">\u003Cstrong>0 (1번째 선수)\u003C/strong>\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\u003C/div>\u003C/div> \u003Cp >a와 b가 라운드가 진행 될 때마다 2로 나눈 값의 올림으로 변경되고, 이 값이 같아질 때 라운드 결과를 반환하게 된다는 것을 파악했습니다. 그 후 이 방식대로 작동하도록 수정해 코드를 개선했습니다.\u003C/p> \u003Cp >그 결과 테스트 케이스 실행 시간이 평균 11.92ms에서 0.04ms로 월등히 빨라졌습니다.\n또한, 배열을 사용한 탓에 27~34번 테스트케이스에서 메모리 사용량이 30메가 더 증가하던 증상이 사라졌습니다.\u003C/p> \u003Cpre class=\"language-javascript\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-javascript\">\u003Cspan class=\"token keyword\">function\u003C/span> \u003Cspan class=\"token function\">solution\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token parameter\">n\u003Cspan class=\"token punctuation\">,\u003C/span> a\u003Cspan class=\"token punctuation\">,\u003C/span> b\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n  \u003Cspan class=\"token keyword\">let\u003C/span> round \u003Cspan class=\"token operator\">=\u003C/span> \u003Cspan class=\"token number\">0\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token keyword\">while\u003C/span> \u003Cspan class=\"token punctuation\">(\u003C/span>a \u003Cspan class=\"token operator\">!==\u003C/span> b\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">&#123;\u003C/span>\n    \u003Cspan class=\"token comment\">//a와 b가 같아질 때까지 반복\u003C/span>\n    round\u003Cspan class=\"token operator\">++\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span> \u003Cspan class=\"token comment\">//라운드 진행\u003C/span>\n\n    \u003Cspan class=\"token comment\">//a와 b를 2로 나누고 올림\u003C/span>\n    a \u003Cspan class=\"token operator\">=\u003C/span> Math\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">ceil\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>a \u003Cspan class=\"token operator\">/\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n    b \u003Cspan class=\"token operator\">=\u003C/span> Math\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">ceil\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>b \u003Cspan class=\"token operator\">/\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token punctuation\">&#125;\u003C/span>\n  \u003Cspan class=\"token keyword\">return\u003C/span> round\u003Cspan class=\"token punctuation\">;\u003C/span>\n\u003Cspan class=\"token punctuation\">&#125;\u003C/span>\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre>",[6,7],"알고리즘","프로그래머스"],"uses":{"params":["permalink"]}}]}

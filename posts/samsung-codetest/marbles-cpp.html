<!DOCTYPE html><html lang="ko" dir="ltr"><head><meta charset="utf-8"><style>:where(img){height:auto}</style>  <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="referrer" content="origin-when-cross-origin"> <meta name="format-detection" content="telephone=no, address=no"> <meta http-equiv="x-ua-compatible" content="ie=edge"> <link rel="icon" type="image/svg+xml" sizes="any" href="/favicon/any.svg"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon/16.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon/32.png"> <link rel="icon" type="image/png" sizes="96x96" href="/favicon/96.png"> <link rel="icon" type="image/png" sizes="180x180" href="/favicon/180.png"> <link rel="apple-touch-icon" sizes="180x180" href="/favicon/180.png"> <link rel="apple-touch-icon" sizes="57x57" href="/favicon/57.png"> <link rel="apple-touch-icon" sizes="60x60" href="/favicon/60.png"> <link rel="apple-touch-icon" sizes="72x72" href="/favicon/72.png"> <link rel="apple-touch-icon" sizes="76x76" href="/favicon/76.png"> <link rel="apple-touch-icon" sizes="114x114" href="/favicon/114.png"> <link rel="apple-touch-icon" sizes="120x120" href="/favicon/120.png"> <link rel="apple-touch-icon" sizes="144x144" href="/favicon/144.png"> <link rel="apple-touch-icon" sizes="152x152" href="/favicon/152.png"> <link rel="apple-touch-icon" sizes="180x180" href="/favicon/180.png"> <meta name="msapplication-square70x70logo" content="/favicon/70.png"> <meta name="msapplication-TileImage" content="/favicon/144.png"> <meta name="msapplication-square150x150logo" content="/favicon/150.png"> <meta name="msapplication-square310x310logo" content="/favicon/310.png"> <link rel="sitemap" type="application/xml" href="/sitemap.xml"> <link rel="alternate" type="application/rss+xml" href="/rss.xml"> <link rel="alternate" type="application/atom+xml" href="/atom.xml"> <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NNGC41131C"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-NNGC41131C")</script> <script>document.documentElement.dataset.theme=localStorage.getItem("color-scheme")||(window&&window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")</script> <link href="/_app/immutable/assets/0.BJZ3lrIf.css" rel="stylesheet"> <link rel="modulepreload" href="/_app/immutable/entry/start.DIS2B-qI.js"> <link rel="modulepreload" href="/_app/immutable/chunks/entry.CvntsCbD.js"> <link rel="modulepreload" href="/_app/immutable/chunks/scheduler.tNaupYda.js"> <link rel="modulepreload" href="/_app/immutable/entry/app.BeorjYF_.js"> <link rel="modulepreload" href="/_app/immutable/chunks/preload-helper.PNuX44LO.js"> <link rel="modulepreload" href="/_app/immutable/chunks/index.QViIPcpX.js"> <link rel="modulepreload" href="/_app/immutable/nodes/0.CWWR_vH2.js"> <link rel="modulepreload" href="/_app/immutable/chunks/clsx.B-dksMZM.js"> <link rel="modulepreload" href="/_app/immutable/chunks/each.D6YF6ztN.js"> <link rel="modulepreload" href="/_app/immutable/chunks/theme.DT_Prusw.js"> <link rel="modulepreload" href="/_app/immutable/chunks/stores.C1yDDIK5.js"> <link rel="modulepreload" href="/_app/immutable/nodes/6.BHXeKvx8.js"> <link rel="modulepreload" href="/_app/immutable/chunks/MetaTags.G__YhRv8.js"><title>🏅 CodeTest : 구슬치기 (C++) - 현재는개발중</title><meta name="description" content="삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다."><meta name="creator" content="김현재"><meta name="publisher" content="김현재"><meta name="author" content="김현재"><meta name="canonical" content="https://present.kim/posts/samsung-codetest/marbles-cpp"><link rel="canonical" href="https://present.kim/posts/samsung-codetest/marbles-cpp"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml"><link rel="self" type="application/atom+xml" href="/atom.xml"><link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS"><meta name="robots" content="index, follow"><meta name="generator" content="SvelteKit v1.20.5"><meta itemprop="name" content="🏅 CodeTest : 구슬치기 (C++) - 현재는개발중"><meta itemprop="description" content="삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다."><meta property="og:type" content="article"><meta property="og:locale" content="ko_KR"><meta property="og:url" content="https://present.kim/posts/samsung-codetest/marbles-cpp"><meta property="og:name" content="현재는개발중"><meta property="og:title" content="🏅 CodeTest : 구슬치기 (C++) - 현재는개발중"><meta property="og:article:author" content="김현재"><meta property="og:description" content="삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="🏅 CodeTest : 구슬치기 (C++) - 현재는개발중"><meta name="twitter:domain" content="https://present.kim"><meta name="twitter:description" content="삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다."><meta name="giscus:backlink" content="https://present.kim/posts/samsung-codetest/marbles-cpp"> </head> <body class="sidebar:overflow-y-hidden h-full overflow-x-hidden"> <div style="display:contents"> <aside aria-label="Sidebar" id="sidebar" class="flex flex-col -translate-x-full bg-mono-200 border-mono-100 border-r ease-in-out-500 fixed h-full justify-between left-0 lg:translate-x-0 max-w-full p-0 sidebar:translate-x-0 text-mono-500 top-0 transition-transform w-64 z-50"><button id="sidebar-toggle-button" aria-label="Open Sidebar" class="ease-in-out-500 bg-mono-200 fixed sidebar:translate-x-0 lg:hidden p-2 right-0 rounded-r-lg scroll-up:translate-x-full scrolled:translate-x-0 top-2 transition-[transform,background] translate-x-full"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" class="[&amp;_*]:transition-transform [&amp;_*]:ease-spring-700 fill-none h-7 lg:hidden stroke-[6px] stroke-current stroke-round w-7"><path class="origin-center -translate-y-3" d="M04,25 46,25"></path><path class="origin-center" d="M04,25 32,25"></path><path class="origin-center translate-y-3" d="M04,25 46,25"></path></svg></button> <header id="sidebar-title" class="flex flex-col items-center mt-16 w-full" data-svelte-h="svelte-1y8m1o4"><div id="profile-wrapper" class="mx-auto relative text-center"><img src="https://avatars.githubusercontent.com/u/13284800?v=4" alt="Profile" class="ring-4 ring-mono-200 rounded-full shadow-2xl h-36 w-36" fetchpriority="high" decoding="async"> <div class="ease-in-out-500 absolute bg-background bottom-2 h-1/5 right-2 ring-4 ring-mono-200 rounded-full shadow-2xl transition-[width_height_bottom_right] w-1/5"><p>😎</p></div></div> <p class="font-bold mt-4 text-xl">현재는 개발중</p></header> <nav class="flex flex-col items-center gap-2 justify-center"><a href="/" class="mx-auto bg-mono-500 bg-opacity-0 ease-in-out-300 hover:bg-opacity-20 items-start pl-6 py-2 rounded-2xl text-start transition-[background-color] w-48"><i class="before:text-3xl home"></i> <span class="font-bold ml-4">Home</span> </a><a href="/posts" class="mx-auto bg-mono-500 bg-opacity-0 ease-in-out-300 hover:bg-opacity-20 items-start pl-6 py-2 rounded-2xl text-start transition-[background-color] w-48"><i class="before:text-3xl list"></i> <span class="font-bold ml-4">Posts</span> </a><a href="/tags" class="mx-auto bg-mono-500 bg-opacity-0 ease-in-out-300 hover:bg-opacity-20 items-start pl-6 py-2 rounded-2xl text-start transition-[background-color] w-48"><i class="before:text-3xl tags"></i> <span class="font-bold ml-4">Tags</span> </a><a href="/about" class="mx-auto bg-mono-500 bg-opacity-0 ease-in-out-300 hover:bg-opacity-20 items-start pl-6 py-2 rounded-2xl text-start transition-[background-color] w-48"><i class="before:text-3xl info"></i> <span class="font-bold ml-4">About</span> </a></nav> <br> <footer id="sidebar-buttons" class="flex flex-row justify-between mb-8 mx-4 w-[calc(100%-2rem)]"><button aria-label="Change Theme" class="sidebar-button [&amp;_*]:origin-center" data-svelte-h="svelte-1pew3qf"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" class="[&amp;_*]:transition-transform [&amp;_*]:ease-spring-500"><mask id="moonMask"><rect class="fill-white" width="50" height="50"></rect><circle class="dark:scale-100 fill-black origin-top-right scale-0" cx="34" cy="14" r="16"></circle></mask><g mask="url(#moonMask)"><circle class="dark:scale-125 fill-current scale-50" cx="25" cy="25" r="16"></circle><g class="fill-none stroke-current stroke-round dark:scale-0 scale-100 stroke-[5px]"><line x1="4" y1="25" x2="12" y2="25"></line><line x1="46" y1="25" x2="38" y2="25"></line><line x1="25" y1="4" x2="25" y2="12"></line><line x1="25" y1="46" x2="25" y2="38"></line><line x1="10" y1="10" x2="15" y2="15"></line><line x1="40" y1="40" x2="35" y2="35"></line><line x1="10" y1="40" x2="15" y2="35"></line><line x1="40" y1="10" x2="35" y2="15"></line></g></g></svg></button> <a aria-label="Contact to E-mail" href="mailto:contanct@present.kim" class="sidebar-button" target="_self"><i class="mail"></i> </a><a aria-label="Contact to Telegram" href="https://t.me/PresentKim" class="sidebar-button" target="_blank"><i class="telegram"></i> </a><a aria-label="Go to Github" href="https://github.com/PresentKim" class="sidebar-button" target="_blank"><i class="github"></i> </a><a aria-label="Go to Blog Feed" href="/atom.xml" class="sidebar-button" target="_blank"><i class="rss"></i> </a></footer></aside> <div id="contents-container" class="ease-in-out-500 w-full lg:translate-x-64 lg:w-[calc(100vw-16rem)] overflow-x-hidden sidebar:translate-x-64 sidebar:w-[calc(100vw-16rem)] transition-[transform,width] translate-x-0"><div class="lg:w-[calc(100vw-16rem)] w-screen"><header id="contents-header" class="flex items-center w-full ease-in-out-500 h-12 justify-start m-auto p-2 select-none transition-[margin]"></header> <main class="blog-container"> <h1 class="text-xl my-2">🏅 CodeTest : 구슬치기 (C++)</h1> <div class="flex flex-row border-b border-mono-200 mb-6 text-center text-sm w-full"><p class="my-auto py-6 text-mono-500">2022-11-08</p> <div class="flex flex-wrap font-bold text-primary"><a class="my-auto bg-foreground bg-opacity-5 mx-1 px-2 py-1 rounded-sm" href="/tags/알고리즘"><code>#알고리즘</code> </a><a class="my-auto bg-foreground bg-opacity-5 mx-1 px-2 py-1 rounded-sm" href="/tags/cpp"><code>#cpp</code> </a><a class="my-auto bg-foreground bg-opacity-5 mx-1 px-2 py-1 rounded-sm" href="/tags/codetest"><code>#codetest</code> </a></div></div> <section id="post" class="article"><h2>문제</h2> <p>유니는 부자가 되고싶어 설레는 마음으로 카지노에갔다. 어떤 게임에 소중한돈을 걸어볼 지 고민하다가, 구슬치기를 하기로 정하였다. 이 카지노의 구슬치기의 룰은 조금 특별하다 게임판은 크기가 NxN인 격자이며 N은 항상 홀수이고 (i, j)는 격자의 i행, j열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이며 ((N+1)/2, (N+1)/2)에는 방망이가 있다. 다음은 N = 3, 5인 경우의 예시이다. 실선은 벽이고 칸에 적혀있는 수는 칸의 번호이다.</p> <p><img src="marbles_01.jpg.jpg" alt="marbles1.png" fetchpriority="high" decoding="async" width="363" height="388"><br> <img src="marbles_02.jpg.jpg" alt="marbles2.png" fetchpriority="high" decoding="async" width="382" height="405"></p> <p>게임을 시작하려면 방향 dK와 거리 sK를 정해야 한다. 위, 아래, 왼쪽, 오른쪽 네가지 방향으로 방망이를 내리칠 수 있고, 정수 방향은 차례대로 1, 2, 3, 4로 나타낸다. 방망이는 dK방향으로 거리가 sK 이하인 모든 칸을 내리쳐 구슬을 파괴한다. 구슬이 파괴되면 그 칸은 구슬이 들어있지 않은 빈 칸이된다. 방망이는 벽을 파괴하지 않는다.</p> <p>다음 예시는 아래방향으로 거리 2만큼 방망이를 내리쳤을 때의 예시이다.</p> <p><img src="marbles_03.jpg.jpg" alt="marbles3.png" fetchpriority="high" decoding="async" width="513" height="567"><br> <img src="marbles_04.jpg.jpg" alt="marbles4.png" fetchpriority="high" decoding="async" width="513" height="566"></p> <p>게임판은 방망이를 중심으로 경사가 져있어서 빈 칸이 생기면 옆에 구슬이 굴러가서 빈칸으로 이동한다. 이 이동은 더이상 구슬이 이동하지 않을때까지 반복되며, 모든 구슬이 이동한 결과는 다음과 같다.</p> <p><img src="marbles_05.jpg.jpg" alt="marbles5.png" fetchpriority="high" decoding="async" width="513" height="566"></p> <p>방망이를 내리치고 구슬의 이동이 끝났다면, 4개 이상 연속하는 구슬이 있을경우 연속된 구슬들은 모두 폭발한다. 다음예시에서 왼쪽그림은 연속하는 구슬을 표시한 것이고, 오른쪽 그림은 구슬이 모두 폭발했을 때를 표시하였다.</p> <p><img src="marbles_06.jpg.jpg" alt="marbles6.png" fetchpriority="high" decoding="async" width="513" height="566"><br> <img src="marbles_07.jpg.jpg" alt="marbles7.png" fetchpriority="high" decoding="async" width="512" height="566"></p> <p>구슬이 폭발한 후 다시 빈칸이 생겼으니 구슬이 경사로 인해 구르기 시작한다. 구슬이 이동한 후에 다시 연속된 구슬이 존재할경우 폭발하며 과정은 더이상 폭발할 수 있는 구슬이 없을때까지 반복된다. 위의 예시에서는 더이상 구슬이 폭발할 수 없으므로 최종상태는 다음과 같다.</p> <p><img src="marbles_08.jpg.jpg" alt="marbles8.png" fetchpriority="high" decoding="async" width="512" height="566"></p> <p>더이상 폭발할 구슬이 없어지면 구슬은 분열을 시작한다. 연속하는 구슬은 서로 연결되며 다음그림은 연결된 구슬들을 표시한 것이다.</p> <p><img src="marbles_09.jpg.jpg" alt="marbles9.png" fetchpriority="high" decoding="async" width="512" height="566"></p> <p>연결된 구슬들은 합쳐진 후 구슬A, B로 분열한다. 구슬 A는 연결된 구슬의 개수이며 B는 연결된 구슬의 번호이다.<br> 구슬은 1번칸부터 차례대로 A, B의 순서로 들어간다. 다음 그림은 구슬이 분열한 후이다. 색은 구분하기 위해 위의 그림에 있는 연결된 구슬의 색을 그대로 사용했다.<br> 만약, 구슬이 칸의 수보다 많아 칸에 들어가지 못하는 구슬이 있으면 그 구슬들은 버린다.</p> <p><img src="marbles_10.jpg.jpg" alt="marbles10.png" fetchpriority="high" decoding="async" width="513" height="566"></p> <p>게임을 총 M번 진행하였을때 점수는 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)가 된다. 위의 예시에서는 2번구슬이 4개, 3번구슬이 4개 폭발하였으므로 2×4 + 3×4, 즉 20점을 획득하였다.</p> <h2>입력</h2> <p>첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 격자에 들어있는 구슬의 정보가 주어진다. i번째 행의 j번째 정수는 (i, j)에 들어있는 구슬의 번호를 의미한다. 어떤 칸에 구슬이 없으면 0이 주어진다. 방망이가 있는 칸도 항상 0이 주어진다.<br> 다음 M개의 줄에는 방망이를 내리치는 방향 dK와 거리 sK가 한 줄에 하나씩 마법을 시전한 순서대로 주어진다. ( 3 ≤ N ≤ 49, 1 ≤ M ≤ 100, 1 ≤ dK ≤ 4, 1 ≤ sK ≤ (N-1)/2 )</p> <h2>출력</h2> <p>첫째 줄에 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)를 출력한다.</p> <pre class="language-예제_입력_1"><code class="language-예제_입력_1">7 1
0 0 0 0 0 0 0
2 3 3 1 1 3 0
1 2 3 3 3 2 0
2 1 1 0 2 2 3
3 1 2 2 3 2 3
1 2 1 3 1 2 3
2 2 3 3 1 2 3
2 2</code></pre> <pre class="language-예제_출력_1"><code class="language-예제_출력_1">20</code></pre> <pre class="language-예제_입력_2"><code class="language-예제_입력_2">7 4
1 1 2 2 2 2 3
2 2 1 1 2 2 3
2 3 3 1 3 1 2
1 2 1 0 3 1 2
3 1 2 2 2 2 2
3 3 2 2 3 1 2
2 1 2 2 2 1 2
2 2
2 3
3 1
2 3</code></pre> <pre class="language-예제_출력_2"><code class="language-예제_출력_2">23</code></pre> <pre class="language-예제_입력_3"><code class="language-예제_입력_3">7 7
1 2 1 2 2 2 3
2 2 2 1 2 2 3
2 2 3 2 3 1 2
1 2 1 0 3 2 1
3 1 2 1 3 3 1
2 1 2 1 2 2 1
2 1 2 1 1 1 1
1 2
2 2
3 3
4 3
2 2
2 3
1 3</code></pre> <pre class="language-예제_출력_3"><code class="language-예제_출력_3">31</code></pre> <hr> <h2>풀이</h2> <p>작성 중</p> <pre class="language-c++"><code class="language-c++">#include &lt;iostream&gt;
#define X 0
#define Y 1
#define MAX 50
using namespace std;

const int LEFT = 0, DOWN = 1, RIGHT = 2, UP = 3, OVER = 4;
const int DK_MAP[5] = {-1, UP, DOWN, LEFT, RIGHT}; //dK =&gt; 방향 매핑
const int MOVES[4][2] = { //방향 =&gt; {x, y} 매핑
  {-1, 0}, //왼쪽
  {0 ,1},  //아래
  {1 ,0},  //오른쪽
  {0, -1}, //위쪽
};

//입력 받은 격자 배열을 1차원 배열로 펼치는 함수
void grid2linear(int n, int (&amp;grid)[MAX][MAX], int arr[]){
  const int center = (n + 1) / 2 - 1; //격자의 중앙 = 방망이의 위치

  int k = 0,
      x = center,
      y = center,
      direction = LEFT, //방향
      walls = 1, //지나가야할 벽의 수
      step = 0; //걸음 수

  for(int i = 0; i &lt; n * n; ++i){
    arr[k++] = grid[x][y];

    x += MOVES[direction][X];
    y += MOVES[direction][Y];

    //걸음 수가 지나가야할 벽의 수와 같다면
    if(++step == walls){
      step = 0; //걸음 수를 초기화하고
      direction = (direction + 1) % 4; //방향을 변경한다

      //만약 변경된 방향이 왼쪽이나 오른쪽이면
      if(direction == RIGHT || direction == LEFT){
        ++walls; //지나가야할 벽의 수를 증가시킨다
      }
    }
  }
}

//구슬을 앞으로 당겨 정렬하는 함수
void sortBeads(int n, int arr[]){
  int k = 1;
  for(int i = 1; i &lt; n * n; ++i){
    if(arr[i] != 0){
      arr[k++] = arr[i];
    }
  }
  for(int i = k; i &lt; n * n; ++i){
    arr[k++] = arr[0];
  }
}

//구슬을 폭발 시키고 얻은 점수를 반환하는 함수
int boomBeads(int n, int arr[]){
  int point = 0, //얻은 점수
      beed = 0, //현재 구슬
      count = 0; //연속된 구슬의 수

  for(int i = 1; i &lt; n * n; ++i){
    if(arr[i] == beed){ //현재 구슬이 연속해서 나온 경우
      ++count; //연속된 구슬의 수를 증가시킨다
    }else{//새 숫자의 구슬이 나온 경우
      if(count &gt;= 4){ //현재 구슬의 개수가 4개 이상이면
        for(int j = i - count; j &lt; i; ++j){
          arr[j] = 0; //연결된 모든 구슬을 폭발 시키고
        }
        point += beed * count; //폭발한 구슬의 점수를 더한다
      }

      //현재 구슬을 업데이트 한다
      beed = arr[i];
      count = 1;
    }
  }

  return point;
}

//방망이 내리치고, 얻은 점수를 반환하는 함수
int hitBat(int n, int arr[]){
  int dK, sK;
  //방망이를 내리치는 방향(dK)와 거리(sK) 입력 받기
  cin &gt;&gt; dK &gt;&gt; sK;

  int direction = DK_MAP[dK];
  int totalPoint = 0;
  while(true){
    int point = boomBeads(n, arr);
    if(point == 0){
      break;
    }
    //1 10 27
    //3 14 33
    //5 18 39
    //7 22 45

    sortBeads(n, arr);
    totalPoint += point;
  }

  return totalPoint;
}

int main() {
  int n, m;
  //격자의 가로세로 길이(N)와
  //방망이를 내리치는 횟수(M) 입력 받기
  cin &gt;&gt; n &gt;&gt; m;

  //격자 정보 입력 받기
  int grid[MAX][MAX];
  for(int x = 0; x &lt; n; ++x){
    for(int y = 0; y &lt; n; ++y){
      cin &gt;&gt; grid[y][x];
    }
  }

  //격자 배열을 1차원 배열로 변환하기
  int linear[n * n];
  grid2linear(n, grid, linear);
  sortBeads(n, linear);

  //방망이 내리치기를 m회 실행하고 점수를 합한다
  int point = 0;
  for(int i = 0; i &lt; m; ++i){
    point += hitBat(n, linear);
  }

/*
  for(int i = 0; i &lt; n * n; ++i){
    cout &lt;&lt; linear[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;*/


  cout &lt;&lt; point;

  return 0;
}</code></pre> <hr></section> <div class="rounded-2xl border border-mono-200 px-2 py-4 shadow" data-nosnippet=""></div></main> <footer class="hover:[&amp;_a]:text-secondary min-h-14 mt-3 py-3 text-mono-500 w-full"><nav class="flex flex-row gap-4 justify-center"><a href="mailto:contanct@present.kim" target="_blank" rel="noopener noreferrer" aria-label="김현재의 이메일" class="w-6"><svg xmlns="http://www.w3.org/2000/svg" role="link" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 7a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2 v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path><path d="m3 7 9 6 9-6"></path></g></svg> </a><a href="https://github.com/PresentKim" target="_blank" rel="noopener noreferrer" aria-label="김현재의 깃허브" class="w-6"><svg xmlns="http://www.w3.org/2000/svg" role="link" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2 4.2 4.2 0 0 0-.1-3.2 s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1 a4.2 4.2 0 0 0-.1 3.2 A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"></path></g></svg> </a><a href="https://present.kim/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="블로그 RSS" class="w-6"><svg xmlns="http://www.w3.org/2000/svg" role="link" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M4 19a1 1 0 1 0 2 0 1 1 0 1 0-2 0M4 4 a16 16 0 0 1 16 16M4 11a9 9 0 0 1 9 9"></path></g></svg> </a></nav> <div class="text-center text-sm [&amp;_a]:underline leading-loose" data-svelte-h="svelte-10qrfc7"><p>© 2023 PresentKim. All Rights Reserved.</p> <p>Made with <a href="https://kit.svelte.dev/">SvelteKit</a> and <a href="https://tailwindcss.com/">TailwindCSS</a></p></div></footer></div></div> <script>{__sveltekit_gk40c0={base:""};const a=document.currentScript.parentElement,b=[null,{type:"data",data:{title:"🏅 CodeTest : 구슬치기 (C++)",summary:"삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다.",formattedDate:"2022-11-08",content:'<h2 >문제</h2> <p >유니는 부자가 되고싶어 설레는 마음으로 카지노에갔다. 어떤 게임에 소중한돈을 걸어볼 지 고민하다가, 구슬치기를 하기로 정하였다. 이 카지노의 구슬치기의 룰은 조금 특별하다 게임판은 크기가 NxN인 격자이며 N은 항상 홀수이고 (i, j)는 격자의 i행, j열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이며 ((N+1)/2, (N+1)/2)에는 방망이가 있다. 다음은 N = 3, 5인 경우의 예시이다. 실선은 벽이고 칸에 적혀있는 수는 칸의 번호이다.</p> <p ><img src="marbles_01.jpg" alt="marbles1.png"><br> <img src="marbles_02.jpg" alt="marbles2.png"></p> <p >게임을 시작하려면 방향 dK와 거리 sK를 정해야 한다. 위, 아래, 왼쪽, 오른쪽 네가지 방향으로 방망이를 내리칠 수 있고, 정수 방향은 차례대로 1, 2, 3, 4로 나타낸다. 방망이는 dK방향으로 거리가 sK 이하인 모든 칸을 내리쳐 구슬을 파괴한다. 구슬이 파괴되면 그 칸은 구슬이 들어있지 않은 빈 칸이된다. 방망이는 벽을 파괴하지 않는다.</p> <p >다음 예시는 아래방향으로 거리 2만큼 방망이를 내리쳤을 때의 예시이다.</p> <p ><img src="marbles_03.jpg" alt="marbles3.png"><br> <img src="marbles_04.jpg" alt="marbles4.png"></p> <p >게임판은 방망이를 중심으로 경사가 져있어서 빈 칸이 생기면 옆에 구슬이 굴러가서 빈칸으로 이동한다. 이 이동은 더이상 구슬이 이동하지 않을때까지 반복되며, 모든 구슬이 이동한 결과는 다음과 같다.</p> <p ><img src="marbles_05.jpg" alt="marbles5.png"></p> <p >방망이를 내리치고 구슬의 이동이 끝났다면, 4개 이상 연속하는 구슬이 있을경우 연속된 구슬들은 모두 폭발한다. 다음예시에서 왼쪽그림은 연속하는 구슬을 표시한 것이고, 오른쪽 그림은 구슬이 모두 폭발했을 때를 표시하였다.</p> <p ><img src="marbles_06.jpg" alt="marbles6.png"><br> <img src="marbles_07.jpg" alt="marbles7.png"></p> <p >구슬이 폭발한 후 다시 빈칸이 생겼으니 구슬이 경사로 인해 구르기 시작한다. 구슬이 이동한 후에 다시 연속된 구슬이 존재할경우 폭발하며 과정은 더이상 폭발할 수 있는 구슬이 없을때까지 반복된다. 위의 예시에서는 더이상 구슬이 폭발할 수 없으므로 최종상태는 다음과 같다.</p> <p ><img src="marbles_08.jpg" alt="marbles8.png"></p> <p >더이상 폭발할 구슬이 없어지면 구슬은 분열을 시작한다. 연속하는 구슬은 서로 연결되며 다음그림은 연결된 구슬들을 표시한 것이다.</p> <p ><img src="marbles_09.jpg" alt="marbles9.png"></p> <p >연결된 구슬들은 합쳐진 후 구슬A, B로 분열한다. 구슬 A는 연결된 구슬의 개수이며 B는 연결된 구슬의 번호이다.<br>\n구슬은 1번칸부터 차례대로 A, B의 순서로 들어간다. 다음 그림은 구슬이 분열한 후이다. 색은 구분하기 위해 위의 그림에 있는 연결된 구슬의 색을 그대로 사용했다.<br>\n만약, 구슬이 칸의 수보다 많아 칸에 들어가지 못하는 구슬이 있으면 그 구슬들은 버린다.</p> <p ><img src="marbles_10.jpg" alt="marbles10.png"></p> <p >게임을 총 M번 진행하였을때 점수는 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)가 된다. 위의 예시에서는 2번구슬이 4개, 3번구슬이 4개 폭발하였으므로 2×4 + 3×4, 즉 20점을 획득하였다.</p> <h2 >입력</h2> <p >첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 격자에 들어있는 구슬의 정보가 주어진다. i번째 행의 j번째 정수는 (i, j)에 들어있는 구슬의 번호를 의미한다. 어떤 칸에 구슬이 없으면 0이 주어진다. 방망이가 있는 칸도 항상 0이 주어진다.<br>\n다음 M개의 줄에는 방망이를 내리치는 방향 dK와 거리 sK가 한 줄에 하나씩 마법을 시전한 순서대로 주어진다. ( 3 ≤ N ≤ 49, 1 ≤ M ≤ 100, 1 ≤ dK ≤ 4, 1 ≤ sK ≤ (N-1)/2 )</p> <h2 >출력</h2> <p >첫째 줄에 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)를 출력한다.</p> <pre class="language-예제_입력_1">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_입력_1">7 1\n0 0 0 0 0 0 0\n2 3 3 1 1 3 0\n1 2 3 3 3 2 0\n2 1 1 0 2 2 3\n3 1 2 2 3 2 3\n1 2 1 3 1 2 3\n2 2 3 3 1 2 3\n2 2</code>\x3c!-- HTML_TAG_END --\x3e</pre> <pre class="language-예제_출력_1">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_출력_1">20</code>\x3c!-- HTML_TAG_END --\x3e</pre> <pre class="language-예제_입력_2">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_입력_2">7 4\n1 1 2 2 2 2 3\n2 2 1 1 2 2 3\n2 3 3 1 3 1 2\n1 2 1 0 3 1 2\n3 1 2 2 2 2 2\n3 3 2 2 3 1 2\n2 1 2 2 2 1 2\n2 2\n2 3\n3 1\n2 3</code>\x3c!-- HTML_TAG_END --\x3e</pre> <pre class="language-예제_출력_2">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_출력_2">23</code>\x3c!-- HTML_TAG_END --\x3e</pre> <pre class="language-예제_입력_3">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_입력_3">7 7\n1 2 1 2 2 2 3\n2 2 2 1 2 2 3\n2 2 3 2 3 1 2\n1 2 1 0 3 2 1\n3 1 2 1 3 3 1\n2 1 2 1 2 2 1\n2 1 2 1 1 1 1\n1 2\n2 2\n3 3\n4 3\n2 2\n2 3\n1 3</code>\x3c!-- HTML_TAG_END --\x3e</pre> <pre class="language-예제_출력_3">\x3c!-- HTML_TAG_START --\x3e<code class="language-예제_출력_3">31</code>\x3c!-- HTML_TAG_END --\x3e</pre> <hr> <h2 >풀이</h2> <p >작성 중</p> <pre class="language-c++">\x3c!-- HTML_TAG_START --\x3e<code class="language-c++">#include &lt;iostream&gt;\n#define X 0\n#define Y 1\n#define MAX 50\nusing namespace std;\n\nconst int LEFT = 0, DOWN = 1, RIGHT = 2, UP = 3, OVER = 4;\nconst int DK_MAP[5] = &#123;-1, UP, DOWN, LEFT, RIGHT&#125;; //dK =&gt; 방향 매핑\nconst int MOVES[4][2] = &#123; //방향 =&gt; &#123;x, y&#125; 매핑\n  &#123;-1, 0&#125;, //왼쪽\n  &#123;0 ,1&#125;,  //아래\n  &#123;1 ,0&#125;,  //오른쪽\n  &#123;0, -1&#125;, //위쪽\n&#125;;\n\n//입력 받은 격자 배열을 1차원 배열로 펼치는 함수\nvoid grid2linear(int n, int (&amp;grid)[MAX][MAX], int arr[])&#123;\n  const int center = (n + 1) / 2 - 1; //격자의 중앙 = 방망이의 위치\n\n  int k = 0,\n      x = center,\n      y = center,\n      direction = LEFT, //방향\n      walls = 1, //지나가야할 벽의 수\n      step = 0; //걸음 수\n\n  for(int i = 0; i &lt; n * n; ++i)&#123;\n    arr[k++] = grid[x][y];\n\n    x += MOVES[direction][X];\n    y += MOVES[direction][Y];\n\n    //걸음 수가 지나가야할 벽의 수와 같다면\n    if(++step == walls)&#123;\n      step = 0; //걸음 수를 초기화하고\n      direction = (direction + 1) % 4; //방향을 변경한다\n\n      //만약 변경된 방향이 왼쪽이나 오른쪽이면\n      if(direction == RIGHT || direction == LEFT)&#123;\n        ++walls; //지나가야할 벽의 수를 증가시킨다\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n//구슬을 앞으로 당겨 정렬하는 함수\nvoid sortBeads(int n, int arr[])&#123;\n  int k = 1;\n  for(int i = 1; i &lt; n * n; ++i)&#123;\n    if(arr[i] != 0)&#123;\n      arr[k++] = arr[i];\n    &#125;\n  &#125;\n  for(int i = k; i &lt; n * n; ++i)&#123;\n    arr[k++] = arr[0];\n  &#125;\n&#125;\n\n//구슬을 폭발 시키고 얻은 점수를 반환하는 함수\nint boomBeads(int n, int arr[])&#123;\n  int point = 0, //얻은 점수\n      beed = 0, //현재 구슬\n      count = 0; //연속된 구슬의 수\n\n  for(int i = 1; i &lt; n * n; ++i)&#123;\n    if(arr[i] == beed)&#123; //현재 구슬이 연속해서 나온 경우\n      ++count; //연속된 구슬의 수를 증가시킨다\n    &#125;else&#123;//새 숫자의 구슬이 나온 경우\n      if(count &gt;= 4)&#123; //현재 구슬의 개수가 4개 이상이면\n        for(int j = i - count; j &lt; i; ++j)&#123;\n          arr[j] = 0; //연결된 모든 구슬을 폭발 시키고\n        &#125;\n        point += beed * count; //폭발한 구슬의 점수를 더한다\n      &#125;\n\n      //현재 구슬을 업데이트 한다\n      beed = arr[i];\n      count = 1;\n    &#125;\n  &#125;\n\n  return point;\n&#125;\n\n//방망이 내리치고, 얻은 점수를 반환하는 함수\nint hitBat(int n, int arr[])&#123;\n  int dK, sK;\n  //방망이를 내리치는 방향(dK)와 거리(sK) 입력 받기\n  cin &gt;&gt; dK &gt;&gt; sK;\n\n  int direction = DK_MAP[dK];\n  int totalPoint = 0;\n  while(true)&#123;\n    int point = boomBeads(n, arr);\n    if(point == 0)&#123;\n      break;\n    &#125;\n    //1 10 27\n    //3 14 33\n    //5 18 39\n    //7 22 45\n\n    sortBeads(n, arr);\n    totalPoint += point;\n  &#125;\n\n  return totalPoint;\n&#125;\n\nint main() &#123;\n  int n, m;\n  //격자의 가로세로 길이(N)와\n  //방망이를 내리치는 횟수(M) 입력 받기\n  cin &gt;&gt; n &gt;&gt; m;\n\n  //격자 정보 입력 받기\n  int grid[MAX][MAX];\n  for(int x = 0; x &lt; n; ++x)&#123;\n    for(int y = 0; y &lt; n; ++y)&#123;\n      cin &gt;&gt; grid[y][x];\n    &#125;\n  &#125;\n\n  //격자 배열을 1차원 배열로 변환하기\n  int linear[n * n];\n  grid2linear(n, grid, linear);\n  sortBeads(n, linear);\n\n  //방망이 내리치기를 m회 실행하고 점수를 합한다\n  int point = 0;\n  for(int i = 0; i &lt; m; ++i)&#123;\n    point += hitBat(n, linear);\n  &#125;\n\n/*\n  for(int i = 0; i &lt; n * n; ++i)&#123;\n    cout &lt;&lt; linear[i] &lt;&lt; &quot; &quot;;\n  &#125;\n  cout &lt;&lt; endl;*/\n\n\n  cout &lt;&lt; point;\n\n  return 0;\n&#125;</code>\x3c!-- HTML_TAG_END --\x3e</pre>',tags:["알고리즘","cpp","codetest"]},uses:{params:["permalink"]}}];Promise.all([import("/_app/immutable/entry/start.DIS2B-qI.js"),import("/_app/immutable/entry/app.BeorjYF_.js")]).then(([n,t])=>{n.start(t,a,{node_ids:[0,6],data:b,form:null,error:null})})}</script> </div> </body></html>
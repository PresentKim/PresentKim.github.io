{"type":"data","nodes":[null,{"type":"data","data":[{"title":1,"summary":2,"formattedDate":3,"content":4,"tags":5},"🏅 CodeTest : 구슬치기 (C++)","삼성 코딩테스트 : 구슬치기 문제를 C++로 풀이한 내용입니다.","2022-11-08","\u003Ch2 >문제\u003C/h2> \u003Cp >유니는 부자가 되고싶어 설레는 마음으로 카지노에갔다. 어떤 게임에 소중한돈을 걸어볼 지 고민하다가, 구슬치기를 하기로 정하였다. 이 카지노의 구슬치기의 룰은 조금 특별하다 게임판은 크기가 NxN인 격자이며 N은 항상 홀수이고 (i, j)는 격자의 i행, j열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이며 ((N+1)/2, (N+1)/2)에는 방망이가 있다. 다음은 N = 3, 5인 경우의 예시이다. 실선은 벽이고 칸에 적혀있는 수는 칸의 번호이다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_01.jpg\" alt=\"marbles1.png\">\u003Cbr> \u003Cimg src=\"marbles_02.jpg\" alt=\"marbles2.png\">\u003C/p> \u003Cp >게임을 시작하려면 방향 dK와 거리 sK를 정해야 한다. 위, 아래, 왼쪽, 오른쪽 네가지 방향으로 방망이를 내리칠 수 있고, 정수 방향은 차례대로 1, 2, 3, 4로 나타낸다. 방망이는 dK방향으로 거리가 sK 이하인 모든 칸을 내리쳐 구슬을 파괴한다. 구슬이 파괴되면 그 칸은 구슬이 들어있지 않은 빈 칸이된다. 방망이는 벽을 파괴하지 않는다.\u003C/p> \u003Cp >다음 예시는 아래방향으로 거리 2만큼 방망이를 내리쳤을 때의 예시이다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_03.jpg\" alt=\"marbles3.png\">\u003Cbr> \u003Cimg src=\"marbles_04.jpg\" alt=\"marbles4.png\">\u003C/p> \u003Cp >게임판은 방망이를 중심으로 경사가 져있어서 빈 칸이 생기면 옆에 구슬이 굴러가서 빈칸으로 이동한다. 이 이동은 더이상 구슬이 이동하지 않을때까지 반복되며, 모든 구슬이 이동한 결과는 다음과 같다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_05.jpg\" alt=\"marbles5.png\">\u003C/p> \u003Cp >방망이를 내리치고 구슬의 이동이 끝났다면, 4개 이상 연속하는 구슬이 있을경우 연속된 구슬들은 모두 폭발한다. 다음예시에서 왼쪽그림은 연속하는 구슬을 표시한 것이고, 오른쪽 그림은 구슬이 모두 폭발했을 때를 표시하였다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_06.jpg\" alt=\"marbles6.png\">\u003Cbr> \u003Cimg src=\"marbles_07.jpg\" alt=\"marbles7.png\">\u003C/p> \u003Cp >구슬이 폭발한 후 다시 빈칸이 생겼으니 구슬이 경사로 인해 구르기 시작한다. 구슬이 이동한 후에 다시 연속된 구슬이 존재할경우 폭발하며 과정은 더이상 폭발할 수 있는 구슬이 없을때까지 반복된다. 위의 예시에서는 더이상 구슬이 폭발할 수 없으므로 최종상태는 다음과 같다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_08.jpg\" alt=\"marbles8.png\">\u003C/p> \u003Cp >더이상 폭발할 구슬이 없어지면 구슬은 분열을 시작한다. 연속하는 구슬은 서로 연결되며 다음그림은 연결된 구슬들을 표시한 것이다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_09.jpg\" alt=\"marbles9.png\">\u003C/p> \u003Cp >연결된 구슬들은 합쳐진 후 구슬A, B로 분열한다. 구슬 A는 연결된 구슬의 개수이며 B는 연결된 구슬의 번호이다.\u003Cbr>\n구슬은 1번칸부터 차례대로 A, B의 순서로 들어간다. 다음 그림은 구슬이 분열한 후이다. 색은 구분하기 위해 위의 그림에 있는 연결된 구슬의 색을 그대로 사용했다.\u003Cbr>\n만약, 구슬이 칸의 수보다 많아 칸에 들어가지 못하는 구슬이 있으면 그 구슬들은 버린다.\u003C/p> \u003Cp >\u003Cimg src=\"marbles_10.jpg\" alt=\"marbles10.png\">\u003C/p> \u003Cp >게임을 총 M번 진행하였을때 점수는 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)가 된다. 위의 예시에서는 2번구슬이 4개, 3번구슬이 4개 폭발하였으므로 2×4 + 3×4, 즉 20점을 획득하였다.\u003C/p> \u003Ch2 >입력\u003C/h2> \u003Cp >첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 격자에 들어있는 구슬의 정보가 주어진다. i번째 행의 j번째 정수는 (i, j)에 들어있는 구슬의 번호를 의미한다. 어떤 칸에 구슬이 없으면 0이 주어진다. 방망이가 있는 칸도 항상 0이 주어진다.\u003Cbr>\n다음 M개의 줄에는 방망이를 내리치는 방향 dK와 거리 sK가 한 줄에 하나씩 마법을 시전한 순서대로 주어진다. ( 3 ≤ N ≤ 49, 1 ≤ M ≤ 100, 1 ≤ dK ≤ 4, 1 ≤ sK ≤ (N-1)/2 )\u003C/p> \u003Ch2 >출력\u003C/h2> \u003Cp >첫째 줄에 1×(폭발한 1번 구슬의 개수) + 2×(폭발한 2번 구슬의 개수) + 3×(폭발한 3번 구슬의 개수)를 출력한다.\u003C/p> \u003Cpre class=\"language-예제_입력_1\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_입력_1\">7 1\n0 0 0 0 0 0 0\n2 3 3 1 1 3 0\n1 2 3 3 3 2 0\n2 1 1 0 2 2 3\n3 1 2 2 3 2 3\n1 2 1 3 1 2 3\n2 2 3 3 1 2 3\n2 2\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cpre class=\"language-예제_출력_1\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_출력_1\">20\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cpre class=\"language-예제_입력_2\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_입력_2\">7 4\n1 1 2 2 2 2 3\n2 2 1 1 2 2 3\n2 3 3 1 3 1 2\n1 2 1 0 3 1 2\n3 1 2 2 2 2 2\n3 3 2 2 3 1 2\n2 1 2 2 2 1 2\n2 2\n2 3\n3 1\n2 3\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cpre class=\"language-예제_출력_2\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_출력_2\">23\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cpre class=\"language-예제_입력_3\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_입력_3\">7 7\n1 2 1 2 2 2 3\n2 2 2 1 2 2 3\n2 2 3 2 3 1 2\n1 2 1 0 3 2 1\n3 1 2 1 3 3 1\n2 1 2 1 2 2 1\n2 1 2 1 1 1 1\n1 2\n2 2\n3 3\n4 3\n2 2\n2 3\n1 3\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Cpre class=\"language-예제_출력_3\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-예제_출력_3\">31\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre> \u003Chr> \u003Ch2 >풀이\u003C/h2> \u003Cp >작성 중\u003C/p> \u003Cpre class=\"language-c++\">\u003C!-- HTML_TAG_START -->\u003Ccode class=\"language-c++\">#include &lt;iostream&gt;\n#define X 0\n#define Y 1\n#define MAX 50\nusing namespace std;\n\nconst int LEFT = 0, DOWN = 1, RIGHT = 2, UP = 3, OVER = 4;\nconst int DK_MAP[5] = &#123;-1, UP, DOWN, LEFT, RIGHT&#125;; //dK =&gt; 방향 매핑\nconst int MOVES[4][2] = &#123; //방향 =&gt; &#123;x, y&#125; 매핑\n  &#123;-1, 0&#125;, //왼쪽\n  &#123;0 ,1&#125;,  //아래\n  &#123;1 ,0&#125;,  //오른쪽\n  &#123;0, -1&#125;, //위쪽\n&#125;;\n\n//입력 받은 격자 배열을 1차원 배열로 펼치는 함수\nvoid grid2linear(int n, int (&amp;grid)[MAX][MAX], int arr[])&#123;\n  const int center = (n + 1) / 2 - 1; //격자의 중앙 = 방망이의 위치\n\n  int k = 0,\n      x = center,\n      y = center,\n      direction = LEFT, //방향\n      walls = 1, //지나가야할 벽의 수\n      step = 0; //걸음 수\n\n  for(int i = 0; i &lt; n * n; ++i)&#123;\n    arr[k++] = grid[x][y];\n\n    x += MOVES[direction][X];\n    y += MOVES[direction][Y];\n\n    //걸음 수가 지나가야할 벽의 수와 같다면\n    if(++step == walls)&#123;\n      step = 0; //걸음 수를 초기화하고\n      direction = (direction + 1) % 4; //방향을 변경한다\n\n      //만약 변경된 방향이 왼쪽이나 오른쪽이면\n      if(direction == RIGHT || direction == LEFT)&#123;\n        ++walls; //지나가야할 벽의 수를 증가시킨다\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n//구슬을 앞으로 당겨 정렬하는 함수\nvoid sortBeads(int n, int arr[])&#123;\n  int k = 1;\n  for(int i = 1; i &lt; n * n; ++i)&#123;\n    if(arr[i] != 0)&#123;\n      arr[k++] = arr[i];\n    &#125;\n  &#125;\n  for(int i = k; i &lt; n * n; ++i)&#123;\n    arr[k++] = arr[0];\n  &#125;\n&#125;\n\n//구슬을 폭발 시키고 얻은 점수를 반환하는 함수\nint boomBeads(int n, int arr[])&#123;\n  int point = 0, //얻은 점수\n      beed = 0, //현재 구슬\n      count = 0; //연속된 구슬의 수\n\n  for(int i = 1; i &lt; n * n; ++i)&#123;\n    if(arr[i] == beed)&#123; //현재 구슬이 연속해서 나온 경우\n      ++count; //연속된 구슬의 수를 증가시킨다\n    &#125;else&#123;//새 숫자의 구슬이 나온 경우\n      if(count &gt;= 4)&#123; //현재 구슬의 개수가 4개 이상이면\n        for(int j = i - count; j &lt; i; ++j)&#123;\n          arr[j] = 0; //연결된 모든 구슬을 폭발 시키고\n        &#125;\n        point += beed * count; //폭발한 구슬의 점수를 더한다\n      &#125;\n\n      //현재 구슬을 업데이트 한다\n      beed = arr[i];\n      count = 1;\n    &#125;\n  &#125;\n\n  return point;\n&#125;\n\n//방망이 내리치고, 얻은 점수를 반환하는 함수\nint hitBat(int n, int arr[])&#123;\n  int dK, sK;\n  //방망이를 내리치는 방향(dK)와 거리(sK) 입력 받기\n  cin &gt;&gt; dK &gt;&gt; sK;\n\n  int direction = DK_MAP[dK];\n  int totalPoint = 0;\n  while(true)&#123;\n    int point = boomBeads(n, arr);\n    if(point == 0)&#123;\n      break;\n    &#125;\n    //1 10 27\n    //3 14 33\n    //5 18 39\n    //7 22 45\n\n    sortBeads(n, arr);\n    totalPoint += point;\n  &#125;\n\n  return totalPoint;\n&#125;\n\nint main() &#123;\n  int n, m;\n  //격자의 가로세로 길이(N)와\n  //방망이를 내리치는 횟수(M) 입력 받기\n  cin &gt;&gt; n &gt;&gt; m;\n\n  //격자 정보 입력 받기\n  int grid[MAX][MAX];\n  for(int x = 0; x &lt; n; ++x)&#123;\n    for(int y = 0; y &lt; n; ++y)&#123;\n      cin &gt;&gt; grid[y][x];\n    &#125;\n  &#125;\n\n  //격자 배열을 1차원 배열로 변환하기\n  int linear[n * n];\n  grid2linear(n, grid, linear);\n  sortBeads(n, linear);\n\n  //방망이 내리치기를 m회 실행하고 점수를 합한다\n  int point = 0;\n  for(int i = 0; i &lt; m; ++i)&#123;\n    point += hitBat(n, linear);\n  &#125;\n\n/*\n  for(int i = 0; i &lt; n * n; ++i)&#123;\n    cout &lt;&lt; linear[i] &lt;&lt; &quot; &quot;;\n  &#125;\n  cout &lt;&lt; endl;*/\n\n\n  cout &lt;&lt; point;\n\n  return 0;\n&#125;\u003C/code>\u003C!-- HTML_TAG_END -->\u003C/pre>",[6,7,8],"알고리즘","cpp","codetest"],"uses":{"params":["permalink"]}}]}

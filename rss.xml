<?xml version='1.0' encoding='utf-8'?><rss xmlns:content="https://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title><![CDATA[ 현재는개발중 RSS Feed ]]></title><description><![CDATA[ 프로그래밍을 좋아하는 김현재의 개발 블로그입니다 ]]></description><link>https://present.kim</link><generator>SvelteKit v1.20.5</generator><lastBuildDate>2024-04-12T00:47:31.876Z</lastBuildDate><pubDate>2024-04-11T11:42:00.000Z</pubDate><item><title><![CDATA[ 📝 KDT : 04월 11일자 수업 정리 ]]></title><link>https://present.kim/posts/kdt/2024/04/11/sql-init</link><guid isPermaLink="false">https://present.kim/posts/kdt/2024/04/11/sql-init</guid><description><![CDATA[ 오늘은 오라클 SQL을 설치하고 SQL에 대해 공부했습니다. ]]></description><pubDate>2024-04-11T11:42:00.000Z</pubDate><content:encoded><![CDATA[ - 사용하는 IDE : Eclipse 2024-03 (4.31.0) - 사용하는 DBMS : Oracle Database Express Edition (XE) Release 11.2.0.2.0 (11gR2). --- # SQL의 큰 구조 ## 테이블(Table) 데이터베이스에서 사용되는 데이터 집합의 단위로 흔히 알고 있는 "표"에 해당합니다. ## 필드(Field) 열에 해당하는 데이터 단위로, 세로줄로 표시됩니다. 외에도 속성(attribute), 혹은 칼럼(column)이라고도 불립니다. ## 레코드(Record) 열에 해당하는 데이터 단위로, 가로줄로 표시됩니다. 외에도 튜플(tuple), 혹은 로우(row)이라고도 불립니다. 데이터베이스에는 SQL(Structured Query Lanuage)가 활용됩니다. SQL는 관계형 데이터베이스 관리 시스템(RDBMS)를 위해 설계된 특수 목적의 프로그래밍 언어입니다. --- # SQL 문법 - 주석문 : `--` 또는 `/* */`를 통해 주석을 작성할 수 있습니다. - 명령어는 대소문자를 구분하지 않습니다. (하지만, 명령어는 대문자로 작성하는 것이 관례입니다.) - 명령어는 세미콜론(`;`)으로 끝납니다. - 명령어는 여러 줄에 걸쳐 작성할 수 있습니다. --- ## 제약조건 (Constraint) SQL에는 필드에 들어갈 수 있는 값과 필드나 테이블 간의 관계를 제한하는 제약조건이 있습니다. ```sql CREATE TABLE booklist ( book_num VARCHAR2(5) NOT NULL PRIMARY KEY, ..., ); ``` 위 처럼 쓰는 경우는 필드 수준의 제약조건이라고 하고, ```sql CONSTRAINT booklist_pk PRIMARY KEY (book_num) ``` 위 처럼 쓰는 경우는 테이블 수준의 제약조건이라고 합니다. ### NOT NULL 필드에 NULL 값을 허용하지 않는 제약조건입니다. SQL의 NULL은 자바의 NULL과 같은 의미입니다. --- ### 기본키 (Primary Key) SQL에는 기본키라는 제약조건이 있습니다. 기본키는 데이블을 구성하는 필드 중 갖는 값이 NOT NULL이고, 서로 다른 값(유일한 값)을 갖고 있어 레코드를 식별할 수 있는 필드입니다. 테이블을 구성하는 필드 중 하나를 기본키로 지정할 수 있습니다. 기본키를 지정함으로서 발생할 수 있는 오류를 미연에 방지하고 탐색 속도를 높힐 수 있습니다. 기본키로 결함을 없애고, 그 상태를 유지하는 것을 객체 무결성이라고 합니다. --- ### 외래키 (Foreign Key) SQL에는 외래키라는 제약조건이 있습니다. 테이블 간의 필수 포함 관계를 구성할 때에 상대 테이블의 특정 필드값을 참조하고, 상대 테이블에 없는 값을 사용할 수 없도록 하는 규칙입니다. 이때 참조의 대상이 될 필드는 기본키(primary key) 또는 유일한 값(unique)이어야 합니다. 외래키로 유지되는 무결성을 참조 무결성이라고 합니다. 예를 들어 `booklist` 테이블에 존재하지 않는 도서의 번호(`book_num`)를 `rentlist` 테이블의 빌려간 도서의 번호로 입력할 수 없도록 하는 것입니다. :::info 도서대여점의 도서목록과 대여목록의 관계 - 도서목록 테이블의 이름 : booklist - 대여목록 테이블의 이름 : rentlist | 필드 이름 | 자료형 | 제약조건 | |-----------|------------|----------| | idx | NUMBER(3) | | | rent_date | DATE | | | bnum | VARCHAR(5) | NOT NULL | | mnum | VARCHAR(5) | NOT NULL | | discount | NUMBER(4) | | | ... | ... | ... | ```sql CREATE TABLE rentlist ( idx NUMBER(3), -- 대여번호 rent_date DATE DEFAULT sysdate, -- 대여일자 (데이터 입력시 현재 날짜로 입력) bnum VARCHAR2(5) NOT NULL, -- 도서번호 mnum VARCHAR2(5) NOT NULL, -- 회원번호 discount NUMBER(4) DEFAULT 500, -- 할인액 (데이터 미입력시 500으로 입력) CONSTRAINT pk PRIMARY KEY (idx), CONSTRAINT fk1 FOREIGN KEY (bnum) REFERENCES booklist (book_num), -- 현재 테이블의 bnum 필드는 booklist 테이블의 book_num 필드를 참조합니다. CONSTRAINT fk2 FOREIGN KEY (mnum) REFERENCES memberlist (member_num) -- 현재 테이블의 mnum 필드는 memberlist 테이블의 member_num 필드를 참조합니다. ); ``` ::: ### 유일값 (Unique) UNIQUE는 필드에 중복된 값을 허용하지 않는 제약조건입니다. 기본키와 유일값은 비슷하지만, 기본키는 NULL을 허용하지 않는 반면, 유일값은 NULL을 허용합니다. ### 조건 (Check) CHECK는 필드에 들어갈 수 있는 값의 범위를 제한하는 제약조건입니다. 제약의 조건에는 TRUE 또는 FALSE를 반환하는 조건식을 사용할 수 있습니다. 이를 이용해 가격이 0 이상이라거나, 성별이 '남자' 또는 '여자'라는 조건 등을 걸 수 있습니다. --- ## 자료형 (Data Type) ### 정수형 - NUMBER(자리수) : 바이트가 아닌 자리수를 입력하는 것에 주의 ### 실수형 - NUMBER(자리수, 소수점 이하 자리수) : 바이트가 아닌 자리수를 입력하는 것에 주의 ### 가변형 문자 (최대 4000 Byte) - VARCHAR2(문자수) : 지정한 문자수를 최대 크기로 갖지만, 실제 문자수만큼의 공간만 차지한다 ### 고정형 문자 (최대 2000 Byte) - CHAR(문자수) : 지정한 문자수를 최대 크기로 갖고, 문자수 만큼의 공간을 차지한다 ### 가변형 유니코드 문자 (최대 4000 Byte) - NVARCHAR2(문자수) : VARCHAR2와 같지만, 유니코드 문자를 저장할 수 있다 ### 고정형 유니코드 문자 (최대 2000 Byte) - NCHAR(문자수) : CHAR와 같지만, 유니코드 문자를 저장할 수 있다 ### 날짜형 - DATE : 주로 사용되는 날짜와 시간을 저장할 수 있는 자료형 (java.sql.Date와 유사) - TIMESTAMP : DATE와 유사하지만, 밀리초까지 저장할 수 있는 자료형 (java.sql.Timestamp와 유사) - SYSDATE : DATE 형식의 현재 날짜와 시간을 반환하는 키워드 - SYSTIMESTAMP : TIMESTAMP 형식의 현재 날짜와 시간을 반환하는 키워드 ### LOB (Large Object) - 대용량 데이터를 저장할 수 있는 타입이지만, 최근에는 별도로 저장하고, 경로만 저장하는 추세이다. - BLOB : 이진 데이터 - CLOB : 문자 데이터 - NCLOB : 유니코드 문자 데이터 ### 더이상 사용되지 않는 자료형 - VARCHAR : VARCHAR2로 대체 - LONG : 최대 2GB의 가변 길이 문자형 - FLOAT : NUMBER로 대체 (2진수 기준 22바이트) - BINARY_FLOAT : 32비트 부동 소수점 - BINARY_DOUBLE : 64비트 부동 소수점 --- # SQL 명령어의 분류 ## 1. DDL 명령어 : 데이터베이스의 구조를 정의하는 명령어 ### 1. `CREATE` : 테이블 또는 뷰, 사용자 등을 생성 ```sql CREATE TABLE table_name ( 필드명1 DATATYPE [DEFAULT 기본값, OR 제약조건 등], 필드명2 DATATYPE [DEFAULT 기본값, OR 제약조건 등], ..., 필드명n DATATYPE [DEFAULT 기본값, OR 제약조건 등] ); ``` :::info CREATE TABLE 의 세부 규칙 1. 테이블의 이름은 객체를 의미할 수 있는 적합한 이름을 사용합니다. (Java의 변수와 유사한 규칙) 2. 다른 테이블과 이름이 중복되지 않게 주의합니다. 3. 한 테이블 내에서도 필드 이름이 중복되지 않게 주의합니다. 4. 각 필드들은 `,`로 구분합니다. 단, 마지막 필드는 `,`를 붙이지 않습니다. 5. CREATE를 비롯한 모든 명령어는 `;`로 끝납니다. 6. 필드 이름 뒤에 DATATYPE은 반드시 지정하고, []안의 내용은 생략 가능합니다. 7. 예약어 명령어 등을 테이블 이름과 필드 이름으로 사용할 수 없습니다. 8. 테이블 생성시 대소문자를 구분하지 않습니다. 9. 보통은 데이터 형식과 용량을 지정하는데, DATE 형식은 별도로 크기를 지정하지 않습니다. 10. 문자데이터의 DATATYPE은 VARCHAR2(10), NUMBER의 DATATYPE은 NUMBER(10) 등으로 지정합니다. 11. 필드의 크기는 반드시 가질 수 있는 최대의 길이로 지정해야합니다. 12. 숫자 데이터 형식의 경우 바이트가 아니라 자리수를 지정한다는 것을 주의합니다. ::: :::info 도서대여점의 도서목록 테이블의 생성 테이블 이름 : booklist | 필드 이름 | 자료형 | 제약조건 | |----------|--------|----------| | book_num | 문자 5자 | NOT NULL | | subject | 문자 30자 | NOT NULL | | makeyear | 숫자 4자 | | | inprice | 숫자 6자 | | | outprice | 숫자 6자 | | ```sql CREATE TABLE booklist ( book_num VARCHAR2(5) NOT NULL, subject VARCHAR2(30) NOT NULL, makeyear NUMBER(4), inprice NUMBER(6), outprice NUMBER(6) ); ``` 여기서 문자열을 담는 자료형인 `CHAR`은 무조건 고정된 크기를 차지합니다. 이를 대신해서 사용되는 `VARCHAR`은 불필요한 공간을 차지하지 않는다는 장점이 있습니다. 오라클에선 보다 더 좋은 성능을 가진 `VARCHAR2`를 지원합니다. 주의할 점은 `NUMBER(4)`의 4는 4바이트가 아닌 4자리 숫자를 의미합니다. 따라서 `NUMBER(4)`는 -9999부터 9999까지의 숫자를 저장할 수 있습니다. ::: :::info 회원리스트의 테이블 생성 테이블 이름 : memberlist | 필드 이름 | 자료형 | 제약조건 | |-------------|-------------|------------------------------------------------| | member_num | VARCHAR(5) | NOT NULL : 필드 레벨로 설정, PRIMARY KEY : 테이블 레벨로 설정 | | member_name | VARCHAR(12) | NOT NULL : 필드 레벨로 설정 | | Phone | VARCHAR(13) | NOT NULL : 필드 레벨로 설정 | | birth | DATE | | | bpoint | NUMBER(6) | | ```sql CREATE TABLE memberlist ( member_num VARCHAR2(5) NOT NULL, member_name VARCHAR2(12) NOT NULL, phone VARCHAR2(13) NOT NULL, birth DATE, bpoint NUMBER(6), CONSTRAINT member_pk PRIMARY KEY (member_num) ); ``` ::: ### 2. `DROP` : 이미 생성되어 있는 테이블 또는 뷰, 사용자 등을 삭제 ```sql DROP TABLE table_name; ``` :::info 도서대여점의 도서목록 테이블의 삭제 ```sql DROP TABLE booklist; ``` ::: ### 3. `ALTER` : 이미 생성되어 있는 테이블 또는 뷰, 사용자 등의 구조를 변경 ```sql ALTER TABLE table_name ADD 필드명 DATATYPE; ALTER TABLE table_name MODIFY 필드명 DATATYPE; ALTER TABLE table_name DROP COLUMN 필드명; ``` :::info 도서대여점의 도서목록 테이블의 수정 ```sql ALTER TABLE booklist ADD pub VARCHAR2(20); ALTER TABLE booklist MODIFY inprice NUMBER(7); ALTER TABLE booklist DROP COLUMN makeyear; ``` ::: ## 2. DML 명령어 : 데이터를 조작하는 명령어 ### 1. `SELECT` : 테이블의 데이터를 조회하는 명령어 ```sql SELECT 필드명1, 필드명2, ... FROM 테이블명; ``` :::info 도서대여점의 도서목록 테이블의 조회 ```sql SELECT * FROM booklist; ``` ::: ### 2. `INSERT` : 테이블에 데이터를 삽입하는 명령어 ### 3. `UPDATE` : 테이블의 데이터를 수정하는 명령어 ### 4. `DELETE` : 테이블의 데이터를 삭제하는 명령어 ## 3. DCL 명령어 : 데이터베이스에 대한 접근을 제어하는 명령어 ### 1. `GRANT` : 특정 사용자에게 특정 권한을 부여 ### 2. `REVOKE` : 특정 사용자에게 특정 권한을 박탈 --- # 시퀀스 (Sequence) 시퀀스는 테이블 내의 중복되지 않는 숫자를 자동으로 생성하는 자동 번호 발생기입니다. 테이블 생성 후 시퀀스를 따로 만들어야 합니다. ## 생성 방법 주로 NUMBER 형식의 기본 키값으로 사용됩니다. ```sql CREATE SEQUENCE 시퀀스명 START WITH 시작값 INCREMENT BY 증가값; ``` ```sql CREATE SEQUENCE book_seq START WITH 1 INCREMENT BY 1; ``` --- ## 사용 방법 ```sql INSERT INTO 테이블명 (기본키, ...) VALUES (시퀀스명.NEXTVAL, ...); ``` ```sql INSERT INTO booklist VALUES (book_seq.NEXTVAL, '스프링 부트 3', 2024, 21000, 27000); ``` --- ## 시퀀스 삭제 ```sql DROP SEQUENCE 시퀀스명; ``` ```sql DROP SEQUENCE book_seq; ``` --- # 뷰 (View) 뷰는 하나 이상의 테이블로부터 유도된 가상 테이블입니다. 뷰는 데이터를 저장하지 않지만, 테이블과 같이 사용할 수 있습니다. ## 생성 방법 ```sql CREATE VIEW 뷰명 AS SELECT 필드명1, 필드명2, ... FROM 테이블명 WHERE 조건; ``` ```sql CREATE VIEW bookview AS SELECT book_num, subject FROM booklist WHERE makeyear > 2010; ``` --- ## 뷰 삭제 ```sql DROP VIEW 뷰명; ``` ```sql DROP VIEW bookview; ``` --- :::info 예제 테이블 만들기 - 테이블 이름 : orders1 | 필드 이름 | 자료형 | 제약조건 | |--------------|--------------|--------------------------------------------------------| | order_id | NUMBER(12,0) | 기본키 (테이블레벨, 제약명 : pk_order) | | order_date | DATE | 기본값은 오늘 날짜 (필드레벨) | | order_mode | VARCHAR2(8) | 'direct'와 'online'만 입력 가능 (테이블레벨, 제약명 : ck_order_mode) | | order_status | NUMBER(2,0) | | | order_total | NUMBER(8,2) | 기본값은 0 (필드레벨) | | sales_rep_id | NUMBER(6,0) | | | promotion_id | NUMBER(6,0) | | ```sql CREATE TABLE orders1 ( order_id NUMBER(12,0), order_date DATE DEFAULT SYSDATE, order_mode VARCHAR2(8), order_status NUMBER(2,0), order_total NUMBER(8,2) DEFAULT 0, customer_id NUMBER(6,0), sales_rep_id NUMBER(6,0), promotion_id NUMBER(6,0), CONSTRAINT pk_order PRIMARY KEY (order_id), CONSTRAINT ck_order_mode CHECK (order_mode IN ('direct', 'online')) ); ``` - customer_id 필드명을 customer_number 로 변경 ```sql ALTER TABLE orders1 RENAME COLUMN customer_id TO customer_number; ``` - promotion_id 필드의 값은 10000에서 99999 사이의 값만 허용 ```sql ALTER TABLE orders1 ADD CONSTRAINT ck_promotion_id CHECK promotion_id >= 10000 AND promotion_id <= 99999); -- 혹은 BETWEEN 사용 ALTER TABLE orders1 ADD CONSTRAINT ck_promotion_id CHECK (promotion_id BETWEEN 10000 AND 99999); ``` - orders1 테이블을 orders2로 복사 ```sql CREATE TABLE orders2 AS SELECT * FROM orders1; ``` ::: --- :::info booklist 테이블에 시퀀스 등록하기 ```sql CREATE SEQUENCE book_seq START WITH 1 INCREMENT BY 1; INSERT INTO booklist VALUES (book_seq.NEXTVAL, '스프링 부트 3 백엔드', 2024, 21000, 27000); INSERT INTO booklist VALUES (book_seq.NEXTVAL, '코딩 자율학습', 2024, 22000, 29700); INSERT INTO booklist VALUES (book_seq.NEXTVAL, '객체 지향의 원리', 2024, 15000, 22500); INSERT INTO booklist VALUES (book_seq.NEXTVAL, '자바 표준 프로그래밍', 2024, 30000, 38700); ``` - 시퀀스 최대 증가값을 14까지로 제한 ```sql ALTER SEQUENCE book_seq MAXVALUE 14; ``` - 시퀀스 삭제 ```sql DROP SEQUENCE book_seq; ``` - 시퀀스 재생성 ```sql CREATE SEQUENCE book_seq START WITH 15 INCREMENT BY 1; ``` - 1부터 1씩 증가하는 member_seq, rent_seq 시퀀스 생성 ```sql CREATE SEQUENCE member_seq START WITH 1 INCREMENT BY 1; CREATE SEQUENCE rent_seq START WITH 1 INCREMENT BY 1; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🐘 PHP 수다떨기 - PHP 자체에 대한 이야기 ]]></title><link>https://present.kim/posts/php/php-talkative-01-intro</link><guid isPermaLink="false">https://present.kim/posts/php/php-talkative-01-intro</guid><description><![CDATA[ PHP에 대해 수다를 떨기 위해 먼저 PHP에 대해 이야기해보는 글입니다. ]]></description><pubDate>2024-04-03T10:12:00.000Z</pubDate><content:encoded><![CDATA[ ![P-H-P-H-P](p-h-p-h-p.png) <br/> # 🚩 개요 제가 [🐘 PHP : 간단하게 알아보는 PHP의 역사](/posts/php/php-history)를 작성한 지 반년이 지났습니다. 사실 PHP에 관련된 글을 작성하려는 시도를 여러번 했었는데, 더 자세히...더 정확히...하고 욕심내다가 결국 대부분의 글이 마무리되지 못한 채 방치되었습니다. 이제는 블로그를 더 이상 방치하지 않고 글을 많이 남기자는 목적을 갖고 글을 적어보기로 했습니다. 너무 정확하거나 많은 정보를 담기보단 그저 수다처럼 가벼운 마음으로 PHP에 대해 이야기해보도록 하겠습니다. --- <br/> # ❓일단, 그래서 PHP 언어는 갑자기 왜요? PHP는 동적으로 웹페이지를 생성하기 위해서 개발된 서버 사이드 스크립트 언어입니다. 일반적인 경우엔 원래 목적대로 웹 어플리케이션을 만들기 위해 사용되는 편입니다. 때문에 PHP에 대한 강좌들도 언어에 대해 잠깐 다룬 뒤 바로 웹 개발에 연관지어 설명하는 경우가 많습니다. 하지만 저는 PHP로 작성된 게임 서버 프로그램([`PMMP`](https://pmmp.io))을 사용하기 위해서 PHP를 익히고 계속 사용중이기 때문에 웹보단 PHP 언어 자체에 더 집중해서 이야기를 해보고 싶었습니다. --- <br/> # 🐘 PHP의 마스코트 **![The elePHPant](php-talkative-01-intro_mascot.png) _The elePHPant_** 요즘엔 언어들마다 마스코트가 있죠. PHP의 마스코트는 위에 있는 `elePHPant`라는 이름의 파란 코끼리입니다. Vincent Pontier에 의해 디자인된 이 마스코트는 문득 `PHP`를 옆에서 보면 코끼리처럼 보인다는 생각에 만들어졌습니다. 이 말을 듣고 _"엥 대체 무슨 말이야?"_ 라고 생각하신 분이 있다면, 저도 똑같이 생각했기 때문에 이해를 도와드릴 사진을 구해왔습니다. ![How to design elePHPant](php-talkative-01-intro_mascot_from_php.png) _개인적으로 중간의 PHP 글자가 더 이쁘다고 생각합니다_ --- <br/> # 📊 PHP 관련 통계 [![W3Techs : 2022.01 ~ 2023.01 서버 사이드 언어 점유율](php-talkative-01-intro_w3techs-server-side.png) _📊W3Techs : 2022.01 ~ 2023.01 서버 사이드 언어 점유율_](https://w3techs.com/technologies/history_overview/programming_language) [![stackoverflow : 2022 스크립트·마크업 언어 선호도·기피도](php-talkative-01-intro_stackoverflow-loved-dreaded-survey.png) _📊stackoverflow : 2022 스크립트·마크업 언어 선호도·기피도_](https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages) [W3Techs](https://w3techs.com/technologies/details/pl-php)의 통계에 따르면 2023년에도 PHP는 77.8%의 높은 점유율로 1위를 꾸준히 유지하고 있고, 수많은 메이저 사이트에서도 사용되고 있습니다. 하지만 [Stackoverflow](https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages) 의 설문조사 결과를 보면 높은 기피도(dreaded)로 무려 하위 9위에 랭크했습니다. 이처럼 PHP는 높은 점유율에 비해 개발자들에게는 미움받는 언어에 속합니다. > PHP로 운영중인 사이트 목록: > > - [Wikipedia.org](https://Wikipedia.org), [Whatsapp.com](https://Whatsapp.com), [WordPress.org](https://Wordpress.org), > [XpressEngine.com](https://www.xpressengine.com), [Pinterest.com](https://Pinterest.com), [Vimeo.com](https://Vimeo.com), > [Pixiv.net](https://www.pixiv.net), [Mozilla.org](https://Mozilla.org), [Tumblr.com](https://Tumblr.com) --- <br/> # ✨ PHP의 특징 <br/> ## C와 Perl 문법 기반 PHP의 문법은 기존 개발자들의 유입을 위해 [C](http://clang.org/)와 [Perl](https://www.perl.org/) 언어의 문법을 많이 차용했습니다. 특히 변수명 앞에 `$`을 붙여야 하는 것과 모든 배열이 연관 배열(map)로 작동한다는 점, 그리고 문자열 결합 연산자가 `+`가 아닌 `.`이라는 점 등이 Perl에서 차용된 대표적인 문법이죠. --- ## HTML 파일에 포함되는 구조 PHP는 프로그래밍 언어가 아닌 일종의 템플릿 언어로 시작되어 PHP 2.0에 들어서며 프로그래밍 언어로 재설계되었습니다. 이러한 역사로 인해 일반적인 프로그래밍 언어와 달리 HTML 문서 내에 삽입되는 구조를 갖고 있는데요. PHP 파일은 아래와 같이 `<?php ... ?>` 태그 안에 PHP 코드가 삽입되고, 이 외의 부분은 `echo` 키워드로 출력된 것과 동일하게 처리됩니다. 설정을 통해 `<?`(SGML) 나 `<%`(ASP)로 시작하는 태그를 사용할 수도 있습니다. 하지만 왠만한 경우엔 이식성 문제로 인해 `<?php`를 사용하는 것이 좋습니다. :::info HTML 내에 삽입된 예시 - PHP 코드 내용 ```php <html><body><?php echo "Hello World!"; ?></body></html> ``` - 출력 결과 ```text <html><body> Hello World! </body></html> ``` ::: 하지만, 스크립트 파일로서 사용될 때는 오히려 `?>` 태그를 사용하지 않는 것이 권장됩니다. 이유는 `?>`로 닫힌 이후에 공백이나 줄바꿈이 있으면 의도치 않은 출력이 생길 수 있기 때문입니다. 또한 PHP에는 `<?=`라는 단축 표현이 있습니다. 이 표현은 `<?php echo`를 대신하여 사용할 수 있습니다. 또한 PHP의 모든 명령문은 C언어처럼 세미콜론(`;`)으로 끝나야 합니다. 하지만 `?>`태그로 닫히면 세미콜론을 생략해도 됩니다. ```php <?= "Hello World!" ?> ``` --- ## 오픈소스 PHP는 오픈소스로 개발되어 있어 누구나 소스코드를 열어볼 수 있고, 수정할 수 있습니다. 이러한 특징으로 인해 PHP는 많은 개발자들에게 사랑받고 있습니다. PHP는 원래 Karma라고 불리는 자체개발 소스관리 시스템을 이용하며 소스 버전을 관리했지만, 2021년에 공격자로 인해 백도어 코드가 삽입된 사건 이후, Github으로 변경하게 되었습니다. - `git.php.net` => [github.com/php](https://github.com/php) --- ## 확장 프로그램 (FFI: Foreign Function Interface) 기본적으로 PHP는 C언어로 작성되어 있습니다. 하지만 모든 기능을 PHP로 구현하면 성능 면에서나 확장성 면에서 문제가 발생할 수 있습니다. 이를 해결하기 위해 PHP는 확장 프로그램을 지원합니다. 일반적으로 이러한 확장 프로그램은 C나 C++로 작성되며, PHP의 내부 API를 사용하여 PHP와 상호 작용합니다. 기본적으로 MySQL이나 XML, JSON, SQLite 등의 데이터베이스를 사용하기 위한 내장 확장들이 지원되고, [PECL(PHP Extension Community Library)](https://pecl.php.net/)에서 이미지 처리나 암호화 등의 다양한 확장 프로그램도 다운로드 받아 사용할 수 있습니다. 이 외에도 사용자가 직접 확장 프로그램을 만들어 사용할 수 있습니다. --- ## PHP의 개선 버전 PHP는 꽤나 느리고 보안성이 좋지 않은 언어로 유명했습니다. 이를 개선하기 위해 여러 프로젝트들이 만들어졌는데요. 대표적으로 Facebook은 [`HHVM`](https://github.com/facebook/hhvm/)이라는 가상머신을 만들어 `JIT`(Just in Time)과 같은 기술을 적용해 성능을 최대한 끌어올렸습니다. > 여담으로 HHVM은 이제 PHP 호환성을 버리고 [`HACK`](https://hacklang.org/)이라는 > PHP 문법과 유사한 자체 개발 언어만 타겟으로 삼고 있지만, 아직도 아래와 같은 밈이... > **![facebook meme](php-talkative-01-intro_facebook-meme.png)** 이 외에도 아예 리눅스 네이티브 바이너리를 만들어내는 [kphp](https://github.com/VKCOM/kphp), `.NET Framework`용으로 컴파일해주는 [PeachPie](https://github.com/peachpiecompiler/peachpie), PHP를 PHP 확장 프로그램으로 만들어주는 [zephir](https://github.com/zephir-lang/zephir) 등 다양하고 흥미로운 프로젝트들이 많이 있습니다. --- <br/> # 📚 마치며 마무리가 좀 갑작스럽지만 생각나는 내용들을 천천히 적는 중이기 때문에 이번 글은 여기서 마치도록 하겠습니다. PHP의 문법에 대한 수다는 다음에 이어서 해보도록 할게요. ![P-H-P-H-P](p-h-p-h-p.png) ]]></content:encoded></item><item><title><![CDATA[ 📝 Google Search Console의 사이트맵을 가져올 수 없음 문제를 해결한 과정 ]]></title><link>https://present.kim/posts/blog/sitemap-issue</link><guid isPermaLink="false">https://present.kim/posts/blog/sitemap-issue</guid><description><![CDATA[ Google Search Console에서 사이트맵을 가져올 수 없음 문제를 해결한 과정을 기록합니다. ]]></description><pubDate>2024-04-02T12:42:00.000Z</pubDate><content:encoded><![CDATA[ 오늘은 오랜기간 저를 고통스럽게 했던 Google Search Console의 `사이트맵을 가져올 수 없음` 문제를 해결한 과정을 기록해보려고 합니다. ![sitemap-issue-failed.png](sitemap-issue-failed.png) _모든 방법에 실패해버린 슬픈 사진_ # 문제 상황 블로그를 만드는 모든 사람이 그러하듯 저도 인터넷에 검색할 때 짠!하고 제 블로그가 나오길 바라고 있었습니다. 그래서 블로그가 준비되자마자 블로그 주소를 구글, 빙은 물론 네이버와 다음의 검색엔진에 전부 등록했죠. 하지만 구글의 Google Search Console에서 `사이트맵을 가져올 수 없음`이라며 블로그가 등록되지 않았습니다. 대부분의 블로그 유입은 구글 검색으로 들어올 것이라고 생각했기 때문에 더 스트레스 받았었죠. 몇 개월의 시간 동안 저와 비슷한 문제를 겪는 사람들의 글을 보며 수많은 해결 방법을 시도해봤지만 결국 실패하고, 글도 쓰지 못한 채 이 문제를 해결하기 위해 시간을 쏟아가 점점 블로그 운영에 대한 의욕을 잃어 한동안 블로그를 방치하게 되었습니다. :::info 제가 시도해본 방법들 > 혹시나 누군가에겐 해결책이 될 수 있으니 제가 시도해본 방법들은 남겨놓을게요. - `sitemap.xml/?test` 처럼 `?`나 `/`를 붙여보세요 - `sitemap.xml` 파일을 `sitemap`로 변경해보세요. - `sitemap.xml` 대신 `rss.xml`이나 `atom.xml` 파일을 만들어보세요. - `robots.txt` 파일에 `Sitemap: https://{당신의 도메인}/sitemap.xml` 를 추가해보세요. - 사이트 속성 말고 도메인 속성으로 등록해서 시도해보세요 - 이미 도메인 속성이라면 `https://{당신의 도메인}/sitemap.xml` 처럼 전체 경로를 입력해보세요. - `{당신의 깃헙 아이디}.github.io`가 아닌 이름으로 레포를 만들고 도메인을 설정해보세요. - GihubPages가 아니라 Vercel 등 다른 플랫폼으로 이전해서 시도해보세요. ::: --- ### 해결 방법 사실 제 문제가 해결된 방법은 너무 간단해서 오히려 이 방법을 시도하지 않은 제가 바보 같았습니다. 어제 "블로그를 다시 하긴 해야하는데..." 하는 생각에 해결 방법을 고민하던 중, "이거 결국 *.github.io에서 리디렉션 되는거잖아?"라는 생각이 들었습니다. 그래서 그냥 해보긴 해야지 하는 심정으로 별 기대없이 Google Search Console에 들어가 `https://presentkim.github.io` 사이트를 추가하고 사이트맵을 등록했더니 바로 등록이 되었습니다. ![sitemap-issue-success.png](sitemap-issue-success.png) _허무할 정도로 간단하게 사이트맵 등록 성공_ # 결론 사이트맵은 등록되었지만, 실제로 페이지가 색인되진 않아서 조금 더 기다려봐야겠지만, 이제 블로그가 검색엔진에 등록되어 누군가에게 도움이 되길 바라는 마음으로 글을 마칩니다. 추후에 색인까지 완료되면 이 글을 수정해서 결과를 자랑해보도록 하겠습니다. ㅎㅎ ]]></content:encoded></item><item><title><![CDATA[ 🎨 코드개선 : 중첩된 조건문을 개선하는 방법 ]]></title><link>https://present.kim/posts/cleancoding/nested-if-statement</link><guid isPermaLink="false">https://present.kim/posts/cleancoding/nested-if-statement</guid><description><![CDATA[ 중첩된 조건문을 개선하는 방법에 대해 서술합니다. ]]></description><pubDate>2023-10-24T16:24:00.000Z</pubDate><content:encoded><![CDATA[ ## _**![Nested If Statements Meme](nested-if-statement_title.png)**_ <br/> ## 🚩 개요 개발을 하다보면 코드가 뭔가 복잡하고 읽고 이해하기 힘들때가 있습니다. 코드의 가독성이 떨어지는 이유 중 가장 흔한 `중첩된 조건문`을 개선하는 방법에 대해 생각해봅시다. --- ## ❕조건문을 작성하는 방식 두가지 중첩된 분기의 조건문을 작성하는 방식은 아래의 두가지로 크게 나뉩니다. <div class='flex flex-row gap-4'> ![sample-01](nested-if-statement_sample_01.png) ![sample-01](nested-if-statement_sample_02.png) </div> 1번의 Bubble Style의 경우 이 포스트의 주제인 중첩 조건문(nested if statement) 방식입니다. 조건식이 위쪽에 모여있어 상단의 분기로 가는 첫번째 흐름은 보기 쉽지만, 아래쪽 라인처럼 `else`가 모여있는 곳의 코드를 파악하기가 굉장히 어렵습니다. 2번의 Gateway Style의 경우 `빠른 반환(early return)`이라고도 불리는 방식입니다. 기존의 코드의 조건식을 반대로 뒤집어 스코프를 벗어나는 되는 부분을 먼저 처리하는 구조이기 때문에, 1번에 비해 훨씬 읽기가 편하고 코드의 흐름이 어디서 중단되는지 파악하기 쉬운 구조를 갖고 있습니다. 위 예제에선 단순하게 `condition1`같은 형식으로 적어서 읽기가 편하지만, 만약 조건문이 아래와 같다면 굉장히 난해한 코드가 됩니다. <div class='flex flex-row gap-4'> ![sample-01](nested-if-statement_sample_03.png) ![sample-01](nested-if-statement_sample_04.png) </div> 사소하지만 2번 방식의 또하나의 장점인 들여쓰기가 줄어든다는 점 덕분에, 줄 길이의 부족으로 두줄이 되는 코드도 한줄에 들어가게 되죠. --- ## 🖐️마침 코드를 먼저 목적에 따라 작성한 뒤 위처럼 개선하는 과정이 있다면, 추후 다시 코드를 읽고 파악할 때 큰 도움이 될 것 같습니다. 가독성이 좋은 코드를 쓰는 습관을 들이기 위해 가장 기초적인 더러운 코드(code smells) 사례를 포스트로 작성해봤는데, 생각보다도 분량이 더 짧은 느낌이네요... 가독성을 위한 포스트를 더 작성하다가 유사한 내용이 나오면 합쳐야겠습니다...ㅎㅎ <br/> ]]></content:encoded></item><item><title><![CDATA[ 🐘 PHP : 간단하게 알아보는 PHP의 역사 ]]></title><link>https://present.kim/posts/php/php-history</link><guid isPermaLink="false">https://present.kim/posts/php/php-history</guid><description><![CDATA[ PHP의 역사를 버전별로 간단히 정리해보았습니다. ]]></description><pubDate>2023-10-24T12:43:00.000Z</pubDate><content:encoded><![CDATA[ ## _**![PHP Logo](php-history_title.png)**_ <br/> ## 🚩 개요 `PHP`는 1994년부터 꾸준한 발전을 거듭하여 현재까지도 업데이트되고 있는 프로그래밍 언어입니다. 많은 개발자들에게 레거시 언어라는 악명으로 유명한 언어인데, 그럼에도 꾸준한 개선이 이뤄지고 있다는 점이 꽤 매력적이었습니다. 이번 기회에 28년이라는 긴 세월 동안 수많은 개발자들의 기여로 발전해온 PHP의 역사를 정리해보고자 이 포스트를 작성하게 되었습니다. 현재 PHP는 `The PHP Group`에서 개발 및 관리를 맡고 있고, [php.net](http://www.php.net)에서 문서를 제공하고 있습니다. 이곳에서는 3.0 이상의 버전만 관리하기 때문에 1.0과 2.0는 [PHP 박물관](https://museum.php.net)에서 확인하실 수 있습니다. --- ## 📜 PHP의 역사 <br/> ### PHP 1.0 `PHP Tools` [(1995년 6월 8일)](https://groups.google.com/g/comp.infosystems.www.authoring.cgi/c/PyJ25gZ6z7A/m/M9FkTUVDfcwJ?pli=1) PHP는 Rasmus Lerdorf가 1994년 개인 웹페이지 개발(이력서 방문 추적)을 위해 Perl 언어로 작성된 CGI(Common Gateway Interface) 도구로부터 시작되었습니다. 자신에게 필요한 기능을 그때그때 만들어 사용하던 중 웹서버의 과부하와 개발의 복잡성을 해결하기 위해 C언어로 Perl 래퍼를 만들었고, 이를 알게된 주변 개발자들의 기여와 기능 요청으로 계속해서 개발되었습니다. 시간이 지나 많은 기능을 추가하고 점차 개선해, 마침내 `Personal Home Page Tools`라 명명한 배포판을 만들었고, 최종적으로 1995년 [PHP Tools의 소스를 공개](http://groups.google.com/group/comp.infosystems.www.authoring.cgi/msg/cc7d43454d64d133) 해 최초의 PHP가 릴리즈 되었습니다. 이 버전의 PHP는 프로그래밍 언어가 아닌 동적 웹 페이지를 손쉽게 작성하기 위해 개발된 도구일 뿐이었고, 구체적인 설계 없이 요구 기능 구현을 위한 많은 수정으로 만들어진 탓에 함수의 이름이나 매개변수의 순서가 일관되지 않은 문제를 갖게 되었습니다. 라스무스는 회고록에서 이에 대해 _"저는 프로그래밍 언어를 작성할 의도가 전혀 없었지만, 이것을 멈추는 방법을 몰랐습니다. [...] 저는 프로그래밍 언어를 작성하는 방법을 전혀 모릅니다. 저는 그저 계속해서 다음 논리적 단계를 추가했습니다."_ 라고 말했습니다. - 회고록 원문 : _"I don't know how to stop it, there was never any intent to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way."_ - 작성 예제 ```text  Hey, you are using Netscape!<p> Sorry, that record does not exist<p> Welcome !<p> You have  credits left in your account.<p> ``` - 출처: [Lerdorf, Rasmus (2007). "Slide 3". slides for 'PHP on Hormones' talk. The PHP Group](http://talks.php.net/show/mysql07key/3) --- ### PHP 2.0 `PHP/FI` (1997년 11월 1일) Rasmus Lerdorf는 PHP Tools를 배포함과 동시에 데이터베이스를 쉽게 사용할 방법을 찾고 있었고, SQL 쿼리를 구문 분석하고 그 결과를 통해 양식과 테이블을 쉽게 만들 수 있도록 도와주는 새로운 CGI 도구를 만들었습니다. `Form Interpreter`라 명명된 이 도구는 이후 PHP와 하나의 프로그램으로 결합되어 `Personal Home Page Construction Kit/Form Interpreter`라는 이름으로 완전히 재작성 되었습니다. 이 버전부터 프로그래밍 언어로 발전한 `PHP/FI`는 간단한 스크립트를 직접 HTML 파일에 배치할 수 있어, C와 Perl 언어로 CGI를 사용해 복잡하게 웹페이지를 작성하던 기존 방식에 비해 매우 쉬운 편이였습니다. 또한, 수많은 CGI 도구를 사용할 때와 달리 오버헤드가 많이 제거되어 웹페이지의 성능이 개선되었고, 기존 개발자가 쉽게 배울 수 있도록 의도적으로 C와 Perl의 구조와 유사하게 설계되었습니다. - 변수명이 `$`로 시작하는 것과 모든 배열(array)이 연관 배열(map)로 작동한다는 점, 문자열 결합을 `+`가 아닌 `.`로 한다는 점 등이 Perl의 영향을 받은 대표적인 문법입니다. --- ### PHP 3.0 `PHP` (1998년 6월 6일) Andi Gutmans와 Zeev Suraski는 PHP/FI의 부족한 기능을 채우고, 엔진을 개선하기 위해 라스무스와 힘을 합쳐 프로그래밍 언어 개발에 협력했습니다. 이 새로운 버전의 이름은 `PHP`라는 약어를 그대로 사용하되, 개인 사용의 의미를 제거한 `PHP:Hypertext Preprocessor`의 재귀적 약어로 정해졌습니다. PHP 3.0에 이르러 객체 지향 프로그래밍의 지원과 강력하고 일관화된 언어 구문으로 더욱 개선되었고, 이에 더해 강력한 확장성으로 수많은 모듈 개발자들의 유입을 불러왔습니다. 이 버전부터 우리가 아는 PHP와 유사한 모습을 갖추게 되었습니다. --- ### PHP 4.0 `PHP` [(2000년 5월 22일)](https://news-web.php.net/php.announce/22) PHP 3.0이 공식적으로 출시된 직후 복잡한 애플리케이션의 성능을 개선하고 PHP 코드 베이스의 모듈성을 개선하기 위해 PHP 코어 재작성 작업이 시작되었습니다. Andi Gutmans와 Zeev Suraski는 본인들의 이름 _Zeev_ 와 _Andi_ 로부터 따온 `Zend Engine`이라는 이름의 새로운 엔진을 만들어 냈고, 성능과 확장성을 크게 개선해 냈습니다. 더 많은 웹 서버, HTTP 세션, 출력 버퍼링, 사용자 입력을 처리하는 보다 안전한 방법 및 몇 가지 새로운 언어 구조에 대한 지원과 같은 기타 주요 기능이 포함된 4.0 버전은 꾸준히 업데이트되어, CLI(Command Line Interface) 지원, `SuperGlobal`변수 지원 등 꾸준한 업데이트로 2008년 8월까지 유지보수 되었습니다. --- ### PHP 5.0 `PHP` [(2004년 7월 13일)](https://news-web.php.net/php.announce/50) 새로 출시된 Zend Engine 2.0으로 구동되는 PHP 5는 객체지향 프로그래밍에 대한 더 많은 지원과 수많은 기능의 추가와 성능 개선, 그리고 보안 강화가 이루어졌습니다. - 주요 사항: 네임스페이스(Namespace), 코드 조각(trait), 삼항 연산자(`?:`), 제네레이터(Generators), 클로저( Native closures), 단축 배열 구문(`[]`), 상수(const), 가변 길이 인수, PDO(PHP Data Object), JSON 함수, 내장 개발 서버, 가비지 컬렉션(Garbage Collection), Phar(php 묶음파일), SQLite3, ... 후속 버전인 PHP6의 개발이 2005년부터 시작되어 유니코드를 기반으로 작동하도록 설계하였는데, 이때 `UTF-16`를 차기 유니코드 인코딩으로 채택해 개발하는 사이, 웹의 표준 유니코드 인코딩 방식이 `UTF-8`로 굳혀지면서 개발자들의 참여가 저조해졌기 때문에 개발이 지체되다 결국 2010년 취소되었습니다. 이후 2015년까지 10년 동안 PHP5 버전에 머무르게 되면서 PHP6에 추가하기 위해 논의되었던 많은 기능이 PHP5 버전에 통합되었지만, 10년이라는 기간 동안 큰 개선이 없던 엔진에 의해 다른 언어에 비해 성능 부분에서 크게 밀려나게 되었습니다. PHP6부터 지원할 예정이었던 유니코드 기능을 5.4에 병합하며 UTF-8을 기본 인코딩으로 채택해 다시 사용자들을 유지하며 2014년 8월 28일 PHP 5.6까지 출시했습니다. --- ### PHP 7.0 `PHP` [(2015년 12월 3일)](https://news-web.php.net/php.announce/167) PHP6으로 출시 예정이었던 차기 버전이 지체되어 10년이 지난 탓에 다음 버전의 이름을 어떻게 정할지에 대한 논의가 활발히 일어났었습니다. 긴 시간 동안 PHP6이 출시되지 않았던 탓에 PHP6을 대상으로 계획되었던 많은 기능들이 5.x 버전에 통합되어버린 상황이었습니다. 문제는 이렇게 추가된 기능들을 PHP6이라고 지칭하는 많은 자료들이 존재하게 되었기 때문에, PHP6이라는 버전을 사용하면 큰 혼동을 야기할 수 있다는 우려가 많았습니다. 특히 PHP6은 실패한 버전이라는 이미지가 너무 강하다는 주장이 힘을 얻어 결국 [투표 결과](https://wiki.php.net/rfc/php6) PHP7이 새로운 릴리즈의 이름으로 채택되었습니다. - 동적 언어의 세계에는 `버전6이 저주받았다`는 미신이 있습니다. 출시되지않은 `MySQL 6`과 실패한 `Perl 6`, 그리고 당사자인 `PHP 6` - 그리고 사실 이미 많은 프로젝트가 여러 이유로 메이저 버전을 건너뛰었기 때문에 크게 상관이 없어 보이기도 했습니다. PHP7의 기반은 _"차세대 PHP" `phpng`_ 라고 불렸던 PHP 브랜치입니다. Dmitry Stogov, Xinchen Hui, Nikita Popov가 참여한 이 브랜치의 목적은 완전한 언어 호환성을 유지하면서 PHP의 성능을 최적화하는 것이었습니다. 이를 위해 Zend 엔진을 리팩토링해 성능은 PHP5.6 대비 2배 향상되고, 메모리 사용량은 80% 감소되었습니다. 오랜 기간에 쌓여온 레거시 프로젝트들이 많은 탓에 이 버전부터를 `ModernPHP`라고 부르기도 합니다. - 주요 사항 : - 함수의 인수와 반환 타입, 클래스의 프로퍼티 타입 명시 지원 - 치명적인 문제를 일으킬 수 있었던 다양한 오류 매커니즘을 `try-catch`가 가능한 예외(Exception)으로 대체 - 화살표 함수(람다식), 널 병합 연산자(`??`), 우주선 연산자(`<=>`), 문자열 음수 오프셋, 익명 클래스, 네임스페이스 그룹화 등 다양한 문법 추가 --- ### PHP 8.0 `PHP` [(2020년 11월 26일)](https://www.php.net/releases/8.0/en.php) PHP7부터 준비해 온 `JIT`(Just-In-Time) 컴파일러가 도입되어 다시 성능이 2배 상승되었습니다. 또한, 읽기 전용 접근자(readonly), 열거형(Enum) 지원, `match`표현식, 널 세이프 연산자 (`?->`), `Attributes` (Java의 Anotation) 등 다양한 기능이 추가되었고, PHP7에 이어 더 다양한 오류가 예외로 변경되었고, `assert`와 같은 예외 처리와 관련된 요소들이 개선되었습니다. --- ## 🖐️마침 이 포스트를 작성하기 위해 많은 문서와 글들을 보며 최대한 정확한 내용으로 작성하려고 노력했지만, 혹시라도 잘못된 정보가 있다면 댓글로 지적해주시면 확인하는대로 정정하도록 하겠습니다. 일단 이 포스트에선 이렇게 큰 틀의 변화만 작성하고 마무리 하도록 하겠습니다. 다음에 시간이 된다면 각 버전마다의 세세한 변경사항을 정리하는 포스트를 작성해보도록 하겠습니다. ## :pushpin: 참고 문헌 - [https://en.wikipedia.org/wiki/PHP](https://en.wikipedia.org/wiki/PHP) - [https://www.php.net/manual/en/history.php.php](https://www.php.net/manual/en/history.php.php) - [https://www.php.net/manual/phpfi2.php](https://www.php.net/manual/phpfi2.php) - [https://www.php.net/manual/php3.php](https://www.php.net/manual/php3.php) ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 133500 : 등대 - Javascript ]]></title><link>https://present.kim/posts/programmers/133500-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/133500-js</guid><description><![CDATA[ 프로그래머스 133500 : 등대 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-14T13:21:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 133500 : 등대](https://school.programmers.co.kr/learn/courses/30/lessons/133500) 인천 앞바다에는 1부터 n까지 서로 다른 번호가 매겨진 등대 n개가 존재합니다. 등대와 등대 사이를 오가는 뱃길이 n-1개 존재하여, 어느 등대에서 출발해도 다른 모든 등대까지 이동할 수 있습니다. 등대 관리자 윤성이는 전력을 아끼기 위하여, 이 중 몇 개의 등대만 켜 두려고 합니다. 하지만 등대를 아무렇게나 꺼버리면, 뱃길을 오가는 배들이 위험할 수 있습니다. 한 뱃길의 양쪽 끝 등대 중 적어도 하나는 켜져 있도록 등대를 켜 두어야 합니다. 예를 들어, 아래 그림과 같이 등대 8개와 7개의 뱃길들이 있다고 합시다. 이 경우 1번 등대와 5번 등대 두 개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있으므로, 배들은 안전하게 운항할 수 있습니다. ![example img](133500-example1.png) 등대의 개수 `n`과 각 뱃길이 연결된 등대의 번호를 담은 이차원 배열 `lighthouse`가 매개변수로 주어집니다. 윤성이가 켜 두어야 하는 등대 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. --- ## 제한사항 - 2 ≤ `n` ≤ 100,000 - `lighthouse`의 길이 = `n – 1` - `lighthouse` 배열의 각 행 `[a, b]`는 `a`번 등대와 `b`번 등대가 뱃길로 연결되어 있다는 의미입니다. - 1 ≤ `a` ≠ `b` ≤ `n` - 모든 등대는 서로 다른 등대로 이동할 수 있는 뱃길이 존재하도록 입력이 주어집니다. --- ## 입출력 예 | n | lighthouse | result | | :-- | :------------------------------------------------------------------------ | :----- | | 8 | [[1, 2], [1, 3], [1, 4], [1, 5], [5, 6], [5, 7], [5, 8]] | 2 | | 40 | [[4, 1], [5, 1], [5, 6], [7, 6], [1, 2], [1, 3], [6, 8], [2, 9], [9, 10]] | 3 | - 예제 #1 본문에서 설명한 예시입니다. - 예제 #2 뱃길은 아래 그림과 같이 연결되어 있습니다. 윤성이가 이중 1, 6, 9번 등대 3개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있게 되고, 이때의 등대 개수 3개가 최소가 됩니다. ![example img](133500-example2.png) --- ## 풀이 과정 먼저 주어진 조건을 파악해봅시다. - 조건 1. _`lighthouse`의 길이 = `n – 1`_ `등대 사이의 길의 수가 등대의 수 -1`이라는 이 조건은 등대의 수와 길의 수가 동일한 아래와 같은 형태의 뱃길가 존재하지 않음을 알려줍니다. **![description img](133500-description1.png)** - 조건 2. _모든 등대는 서로 다른 등대로 이동할 수 있는 뱃길이 존재하도록 입력이 주어집니다._ `모든 등대는 다른 등대와 길이 연결되어 있다`라는 이 조건은 아래와 같은 형태의 뱃길이 존재하지 않음을 알려줍니다. **![description img](133500-description2.png)** --- 위 두가지 조건을 통해 뱃길에는 항상 끝에 위치한 등대가 존재하고, 모든 등대는 1개 이상의 길과 연결되어있음을 파악했습니다. 이제 가장 적은 수의 등대만 켜기 위해 반드시 켜져야하는 등대를 찾아야합니다. 먼저 끝에 위치한 등대, 즉, 길이 1개뿐인 등대는 반드시 자신 혹은 연결된 등대가 켜져야합니다. 이때 자신을 켜는 경우엔 무조건 1개의 길만 밝혀지지만 연결된 등대의 불빛을 켤 경우 여러개의 길이 밝혀질 수 있기 때문에 연결된 등대의 불빛을 켜도록 합니다. 이 후 불빛의 영향을 받아 불빛이 필요 없어진 등대를 목록에서 제거하고 이 과정을 반복해 반드시 불빛이 켜져야하는 최소한의 등대의 수를 구할 수 있습니다. --- 먼저 등대의 연결관계를 관리하기 위해 LightHouse 클래스를 작성했습니다. 등대 번호를 담는 `id`, 연결된 등대 객체를 담는 `connects`를 가진 클래스입니다. 연결과 연결 해제를 처리하는 메소드까지 먼저 작성해두겠습니다. ```javascript class Lighthouse { constructor(id) { this.id = id; this.connects = new Map(); } //다른 등대와 연결시키는 함수 //자신과 다른 등대의 연결 목록에 서로를 추가함 connect(target) { this.connects.set(target.id, target); target.connects.set(this.id, this); } //다른 등대와 연결을 해제시키는 함수 disconnect(target) { this.connects.delete(target.id); target.connects.delete(this.id); } } ``` 그 후 solution 함수에서 모든 등대의 연결 관계를 기록합니다. 저는 등대 객체와의 구분을 위해 solution 함수의 인자를 `lighthouse` 대신 `connects`로 변경했습니다. ```javascript function solution(n, connects) { //n개의 등대 객체가 담긴 2차원 배열 생성 const lighthouses = new Map( [...Array(n).keys()].map((i) => [i + 1, new Lighthouse(i + 1)]) ); //모든 등대의 연결 관계를 적용 connects .map(([a, b]) => [lighthouses.get(a), lighthouses.get(b)]) .forEach(([a, b]) => a.connect(b)); return 0; } ``` 자신과 연결된 등대의 수가 1개인지 확인 하는 메소드와 제거할 수 있는 등대의 목록을 반환하는 메소드를 작성했습니다. ```javascript //연결된 등대의 수가 1개인지 확인하는 함수 //연결된 등대의 수가 1개인 경우 반드시 연결된 등대의 불빛이 켜져야함 hasOnlyOneConnect(){ return this.connects.size === 1; } //제거할 수 있는 등대를 반환하는 함수 //연결된 등대가 1개인 경우, 연결된 등대의 모든 연결을 해제시키고 모든 연결이 해제된 등대의 목록를 반환 getRemovalTargets(){ //모든 연결이 해제되어 제거될 등대를 담는 배열 //(== 불빛이 켜질 필요가 없는 등대를 담는 배열) const removed = []; //자신에게 연결된 등대가 1개인 경우 if(this.hasOnlyOneConnect()){ //자신과 연결된 등대 (== 불빛이 켜질 등대) const connect = this.connects.values().next().value; //자신과 연결된 등대의 모든 연결을 해제시키고, 모든 연결이 해제된 등대를 제거 목록에 추가 //(== 자신과 연결된 등대의 불빛을 켜고, 불빛이 켜질 필요가 없는 등대를 제거 목록에 추가) connect.connects.forEach(el => el.disconnect(connect) && removed.push(el)); //자신과 연결된 등대도 제거 목록에 추가 //(== 불빛이 켜진 등대도 제거 목록에 추가) removed.push(connect); } //제거할 등대 목록을 제거 return removed; } ``` 마지막으로 solution 함수에서 모든 길이 밝혀질 때까지 반복하고 답을 반환하는 코드를 작성합니다. ```javascript let answer = 0; //모든 등대가 제거될 때 까지 반복 while (lighthouses.size > 0) { lighthouses.forEach((lighthouse) => { const targets = lighthouse.getRemovalTargets(); if (targets.length) { //제거할 등대가 존재하는 경우 (== 등대의 불빛이 켜진 경우) //불빛이 켜진 등대의 수를 증가시키고 제거할 등대를 lighthouse에서 제거 answer++; targets.forEach((el) => lighthouses.delete(el.id)); } }); } //불빛이 켜진 등대의 수를 반환 return answer; ``` --- ## 최종 코드 ```javascript class Lighthouse { constructor(id) { this.id = id; this.connects = new Map(); } //다른 등대와 연결시키는 함수함수 //본인과 다른 등대의 자식에 서로를 추가함 connect(target) { this.connects.set(target.id, target); target.connects.set(this.id, this); } //다른 등대와 연결을 해제하고, 모든 연결이 해제되었는 지 여부를 반환 disconnect(target) { this.connects.delete(target.id); return this.connects.size === 0; } //연결된 등대의 수가 1개인지 확인하는 함수 //연결된 등대의 수가 1개인 경우 반드시 연결된 등대의 불빛이 켜져야함 hasOnlyOneConnect() { return this.connects.size === 1; } //제거할 수 있는 등대를 반환하는 함수 //연결된 등대가 1개인 경우, 연결된 등대의 모든 연결을 해제시키고 모든 연결이 해제된 등대의 목록를 반환 getRemovalTargets() { //모든 연결이 해제되어 제거될 등대를 담는 배열 //(== 불빛이 켜질 필요가 없는 등대를 담는 배열) const removed = []; //자신에게 연결된 등대가 1개인 경우 if (this.hasOnlyOneConnect()) { //자신과 연결된 등대 (== 불빛이 켜질 등대) const connect = this.connects.values().next().value; //자신과 연결된 등대의 모든 연결을 해제시키고, 모든 연결이 해제된 등대를 제거 목록에 추가 //(== 자신과 연결된 등대의 불빛을 켜고, 불빛이 켜질 필요가 없는 등대를 제거 목록에 추가) connect.connects.forEach( (el) => el.disconnect(connect) && removed.push(el) ); //자신과 연결된 등대도 제거 목록에 추가 //(== 불빛이 켜진 등대도 제거 목록에 추가) removed.push(connect); } //제거할 등대 목록을 제거 return removed; } } function solution(n, connects) { //n개의 등대 객체가 담긴 2차원 배열 생성 const lighthouses = new Map( [...Array(n).keys()].map((i) => [i + 1, new Lighthouse(i + 1)]) ); //모든 등대의 연결 관계를 적용 connects .map(([a, b]) => [lighthouses.get(a), lighthouses.get(b)]) .forEach(([a, b]) => a.connect(b)); let answer = 0; //모든 등대가 제거될 때 까지 반복 while (lighthouses.size > 0) { lighthouses.forEach((lighthouse) => { const targets = lighthouse.getRemovalTargets(); if (targets.length) { //제거할 등대가 존재하는 경우 (== 등대의 불빛이 켜진 경우) //불빛이 켜진 등대의 수를 증가시키고 제거할 등대를 lighthouse에서 제거 answer++; targets.forEach((el) => lighthouses.delete(el.id)); } }); } //불빛이 켜진 등대의 수를 반환 return answer; } ``` - [ ] TODO: 추후 코드와 설명을 다시 정리할 예정입니다. 코드랑 설명이 너무 장황하게 작성된 느낌이 강해서... ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 120866 : 안전지대 - Javascript ]]></title><link>https://present.kim/posts/programmers/120866-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/120866-js</guid><description><![CDATA[ 프로그래머스 120866 : 안전지대 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-04T22:56:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 120866 : 안전지대](https://school.programmers.co.kr/learn/courses/30/lessons/120866) 다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다. **![description.png](120866-description.png)** 지뢰는 2차원 배열 board에 1로 표시되어 있고 board에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다. 지뢰가 매설된 지역의 지도 board가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요. --- ## 제한사항 - board는 $n * n$ 배열입니다. - 1 ≤ n ≤ 100 - 지뢰는 1로 표시되어 있습니다. - board에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다. --- ## 입출력 예 | board | result | | :----------------------------------------------------------------------------------------------------------------------- | :----- | | [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]] | 16 | | [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0]] | 13 | | [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] | 0 | - 예제 #1 (3, 2)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선 총 8칸은 위험지역입니다. 따라서 16을 return합니다. - 예제 #2 (3, 2), (3, 3)에 지뢰가 있으므로 지뢰가 있는 지역과 지뢰와 인접한 위, 아래, 좌, 우, 대각선은 위험지역입니다. 따라서 위험지역을 제외한 칸 수 13을 return합니다. - 예제 #2 모든 지역에 지뢰가 있으므로 안전지역은 없습니다. 따라서 0을 return합니다. --- ## 풀이 과정 먼저 주어진 2차원 배열에서 지뢰가 매설 된 지역 주변을 안전한 지역을 위험지역으로 바꿉니다. - 안전한 지역은 0, 지뢰가 매설 된 지역은 1로 표현되기 때문에 위험지역을 2로 표현했습니다. 그 후 남은 안전지역의 수를 반환합니다. ```javascript const SAFE = 0; //안전한 지역 const BOOM = 1; //지뢰가 매설 된 지역 const WARN = 2; //위험지역 function solution(board) { //board는 n*n의 배열이기 때문에 n을 구함 const n = board.length; //주어진 지역과 인접한 안전한 지역을 위험지역으로 변경하는 함수 const markWarn = (x, y) => { //board를 벗어나지 않는 탐색 범위를 반환하는 함수 const range = (k) => [Math.max(0, k - 1), k, Math.min(n - 1, k + 1)]; //주어진 x, y로 구한 범위 내의 안전한 지역을 위험 지역으로 변경 for (const ry of range(y)) { for (const rx of range(x)) { if (board[ry][rx] === SAFE) { board[ry][rx] = WARN; } } } }; //모든 요소를 순회하여 위험지역을 표시 for (let y = 0; y < n; ++y) { for (let x = 0; x < n; ++x) { if (board[y][x] === BOOM) { markWarn(x, y); } } } //보드를 1차원 배열로 바꾸고, 안전한 지역의 수를 구해 반환 return board.flat().filter((el) => el === SAFE).length; } ``` --- ### 개선 기존 방식과 정반대로, 확인할 지역과 인접 지역에 지뢰가 매설된 지역이 있는지를 확인해 안전한 지역의 수를 구하는 방식으로 변경했습니다. 이를 통해 코드를 더 직관적으로 개선할 수 있었고, 불필요하게 많은 배열 수정 및 접근 횟수를 줄일 수 있었습니다. ```javascript function solution(board) { //board는 n*n의 배열이기 때문에 n을 구함 const n = board.length; //주어진 지역이 안전한 지역인지 확인하는 함수 const isSafe = (x, y) => { const range = (k) => [k - 1, k, k + 1]; //범위 내에 지뢰가 매설된 지역이 존재하면 false를 반환 for (const ry of range(y)) { for (const rx of range(x)) { if (board[ry]?.[rx]) { return false; } } } //주변 지역이 모두 빈 지역이면 true를 반환 return true; }; //모든 지역을 순회하여 안전한 지역의 수를 구해 반환 let answer = 0; for (let y = 0; y < n; ++y) { for (let x = 0; x < n; ++x) { answer += isSafe(x, y); } } return answer; } ``` 문제에서 0은 안전한 지역이 아니라 지뢰가 매설되지 않은 지역을 의미하기 때문에 이 풀이가 더 자연스러운 것 같습니다. ~~처음에 왜 저렇게 풀었지..~~ --- ## 숏코딩 (CodeGolf) 조금 더 코드를 간결하게 바꾸어 아래와 같이 정리할 수 있습니다. ```c solution=_=>_.flatMap((r,y)=>r.map((v,x)=>{for(i=-1;i<2;++i)for(j=-1;j<2;++j)if(_[y+i]?.[x+j])return 0;return 1})).filter(v=>v).length ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 120871 : 저주의 숫자 3 - Javascript ]]></title><link>https://present.kim/posts/programmers/120871-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/120871-js</guid><description><![CDATA[ 프로그래머스 120871 : 저주의 숫자 3 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-04T14:56:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 120871 : 저주의 숫자 3](https://school.programmers.co.kr/learn/courses/30/lessons/120871) 3x 마을 사람들은 3을 저주의 숫자라고 생각하기 때문에 3의 배수와 숫자 3을 사용하지 않습니다. 3x 마을 사람들의 숫자는 다음과 같습니다. | 10진법 | 3x 마을에서 쓰는 숫자 | 10진법 | 3x 마을에서 쓰는 숫자 | | :----: | :-------------------: | :----: | :-------------------: | | 1 | 1 | 6 | 8 | | 2 | 2 | 7 | 10 | | 3 | 4 | 8 | 11 | | 4 | 5 | 9 | 14 | | 5 | 7 | 10 | 16 | 정수 `n`이 매개변수로 주어질 때, `n`을 3x 마을에서 사용하는 숫자로 바꿔 return하도록 solution 함수를 완성해주세요. --- ## 제한사항 - 1 ≤ `n` ≤ 100 --- ## 입출력 예 | n | result | | :-- | :----- | | 15 | 25 | | 40 | 76 | - 예제 #1 15를 3x 마을의 숫자로 변환하면 25입니다. - 예제 #2 40을 3x 마을의 숫자로 변환하면 76입니다. --- ## 풀이 과정 먼저 반복문을 만들어 `answer`를 `n`값이 될때까지 1씩 증가시킵니다. 이 때, `answer`가 3의 배수거나 3이 포함되는 경우에 추가로 증가시켜 3x마을의 저주를 피하도록 작성했습니다. ```javascript function solution(n) { let answer = 0; //actual은 answer이 실제 의미하는 값 //actual이 n이 될 때 까지 answer를 증가시시킴 for (let actual = 1; actual <= n; ++actual) { answer++; //answer이 3의 배수거나, 3이 포함된 숫자인 경우 아니게 될때 까지 추가로 증가시킴 while (answer % 3 === 0 || `${answer}`.includes('3')) { answer++; } } return answer; } ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 120876 : 겹치는 선분의 길이 - Javascript ]]></title><link>https://present.kim/posts/programmers/120876-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/120876-js</guid><description><![CDATA[ 프로그래머스 120876 : 겹치는 선분의 길이 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-03T23:12:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 120876 : 겹치는 선분의 길이](https://school.programmers.co.kr/learn/courses/30/lessons/120876) 선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열 `lines`가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요. `lines`가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다. ![example img](120876-example.png) 선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1]로 길이 2만큼 겹쳐있습니다. --- ## 제한사항 - `lines`의 길이 = 3 - `lines`의 원소의 길이 = 2 - 모든 선분은 길이가 1 이상입니다. - `lines`의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다. - -100 ≤ a $<$ b ≤ 100 --- ## 입출력 예 | lines | result | | :------------------------ | :----- | | [[0, 1], [2, 5], [3, 9]] | 2 | | [[-1, 1], [1, 3], [3, 9]] | 0 | | [[0, 5], [3, 9], [1, 10]] | 8 | - 예제 #1 두 번째, 세 번째 선분 [2, 5], [3, 9]가 [3, 5] 구간에 겹쳐있으므로 2를 return 합니다. - 예제 #2 겹친 선분이 없으므로 0을 return 합니다. - 예제 #2 - 첫 번째와 두 번째 선분이 [3, 5] 구간에서 겹칩니다. - 첫 번째와 세 번째 선분 [1, 5] 구간에서 겹칩니다. - 두 번째와 세 번째 선분 [3, 9] 구간에서 겹칩니다. - 따라서 [1, 9] 구간에 두 개 이상의 선분이 겹쳐있으므로, 8을 return 합니다. --- ## 풀이 과정 배열을 하나 생성해 선분이 놓이는 위치의 값을 1씩 증가시키고, 1을 초과하는 요소의 수를 반환하는 간단한 방법으로 시도했습니다. ```javascript function solution(lines) { //선분이 존재하는 위치를 배열에 담음 const line = []; for (const [start, end] of lines) { for (let i = start; i < end; ++i) { line[i] = (line[i] ?? 0) + 1; } } //배열의 요소 중 1을 초과하는 요소의 수를 반환 return line.filter((count) => count > 1).length; } ``` 하지만 위 코드는 start와 end가 음수인 경우 제대로 작동하지 않아 실패했습니다. 음수를 처리하기 위해 배열이 아닌 맵에 담도록 수정했습니다. ```javascript function solution(lines) { //선분이 존재하는 위치를 맵에 담음 const line = new Map(); for (let [start, end] of lines) { for (let i = start; i < end; ++i) { line.set(i, (line.get(i) ?? 0) + 1); } } //맵의 요소 중 1을 초과하는 요소의 수를 반환 return [...line.values()].filter((count) => count > 1).length; } ``` --- ### 또다른 방법 배열 대신 맵을 사용 방법으로 이미 해결했지만 배열을 사용하지 못했던 이유는 음수 인덱스를 제대로 처리하지 못하기 때문인데, 이 문제의 경우 `line`의 요소의 값이 -100 이상으로 제한 되어있기 때문에 아래와 같이 인덱스에 100을 더하는 방식으로도 해결할 수 있습니다. ```javascript function solution(lines) { //선분이 존재하는 위치를 배열에 담음 const line = []; for (const [start, end] of lines) { for (let i = start; i < end; ++i) { //음수를 처리하기 위해 인덱스에 100을 더함 (-100 이상이기 때문) line[i + 100] = (line[i + 100] ?? 0) + 1; } } //배열의 요소 중 1을 초과하는 요소의 수를 반환 return line.filter((count) => count > 1).length; } ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 120875 : 평행 - Javascript ]]></title><link>https://present.kim/posts/programmers/120875-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/120875-js</guid><description><![CDATA[ 프로그래머스 120875 : 평행 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-03T21:12:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 120875 : 평행](https://school.programmers.co.kr/learn/courses/30/lessons/120875) 점 네 개의 좌표를 담은 이차원 배열 `dots`가 다음과 같이 매개변수로 주어집니다. - [[x1, y1], [x2, y2], [x3, y3], [x4, y4]] 주어진 네 개의 점을 두 개씩 이었을 때, 두 직선이 평행이 되는 경우가 있으면 1을 없으면 0을 return 하도록 solution 함수를 완성해보세요. --- ## 제한사항 - `dots`의 길이 = 4 - `dots`의 원소는 [x, y] 형태이며 x, y는 정수입니다. - 0 ≤ x, y ≤ 100 - 서로 다른 두개 이상의 점이 겹치는 경우는 없습니다. - 두 직선이 겹치는 경우(일치하는 경우)에도 1을 return 해주세요. - 임의의 두 점을 이은 직선이 x축 또는 y축과 평행한 경우는 주어지지 않습니다. --- ## 입출력 예 | dots | result | | :-------------------------------- | :----- | | [[1, 4], [9, 2], [3, 8], [11, 6]] | 1 | | [[3, 5], [4, 1], [2, 4], [5, 10]] | 0 | - 예제 #1 점 [1, 4], [3, 8]을 잇고 [9, 2], [11, 6]를 이으면 두 선분은 평행합니다. - 예제 #2 점을 어떻게 연결해도 평행하지 않습니다. --- ## 풀이 과정 먼저 주어진 4개의 점을 a, b, c, d라고 하면 두 점씩 잇는 방법은 아래와 같습니다. - [a, b], [c, d] - [a, c], [b, d] - [a, d], [b, c] 이 외에는 두 점씩 묶는 방법이 없기 때문에 이 3가지 경우 중 하나라도 두 선이 평행하면 1을 반환하면 됩니다. 두 선의 기울기가 같으면 평행한 것이기 때문에 점으로 만들어진 직선의 기울기를 구해서 확인했습니다. ```javascript function solution(dots) { //두 점의 인덱스가 주어지면 두점을 이은 직선의 각도를 반환하는 함수 const angle = (a, b) => (dots[a][0] - dots[b][0]) / (dots[a][1] - dots[b][1]); //직선을 만들 수 있는 모든 방법을 인덱스로 표현하고, 모두 확인 for (const [a1, b1, a2, b2] of [ [0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 1, 2] ]) { //만약 두 직선의 각도가 같다면 1을 반환 if (angle(a1, b1) === angle(a2, b2)) { return 1; } } //두 직선의 각도가 같은 조합이 없는 경우 0을 반환 return 0; } ``` --- ### 코드 개선 `dots` 인자 자체를 풀이와 동일하게 a,b,c,d로 받으면 전반적인 코드를 더 간단하게 만들 수 있습니다. ```javascript //두 점을 이은 직선의 각도를 반환하는 함수 const angle = (a, b) => (a[0] - b[0]) / (a[1] - b[1]); function solution([a, b, c, d]) { //직선을 만들 수 있는 모든 방법을 확인 for (const [a1, b1, a2, b2] of [ [a, b, c, d], [a, c, b, d], [a, d, b, c] ]) { //만약 두 직선의 각도가 같다면 1을 반환 if (angle(a1, b1) === angle(a2, b2)) { return 1; } } //두 직선의 각도가 같은 조합이 없는 경우 0을 반환 return 0; } ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 42893 : 매칭 점수 - Javascript ]]></title><link>https://present.kim/posts/programmers/42893-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/42893-js</guid><description><![CDATA[ 프로그래머스 42893 : 매칭 점수 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-03-01T23:48:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 42893 : 매칭 점수](https://school.programmers.co.kr/learn/courses/30/lessons/42893) 프렌즈 대학교 조교였던 제이지는 허드렛일만 시키는 네오 학과장님의 마수에서 벗어나, 카카오에 입사하게 되었다. 평소에 관심있어하던 검색에 마침 결원이 발생하여, 검색개발팀에 편입될 수 있었고, 대망의 첫 프로젝트를 맡게 되었다. 그 프로젝트는 검색어에 가장 잘 맞는 웹페이지를 보여주기 위해 아래와 같은 규칙으로 검색어에 대한 웹페이지의 매칭점수를 계산 하는 것이었다. - 한 웹페이지에 대해서 기본점수, 외부 링크 수, 링크점수, 그리고 매칭점수를 구할 수 있다. - 한 웹페이지의 기본점수는 해당 웹페이지의 텍스트 중, 검색어가 등장하는 횟수이다. (대소문자 무시) - 한 웹페이지의 외부 링크 수는 해당 웹페이지에서 다른 외부 페이지로 연결된 링크의 개수이다. - 한 웹페이지의 링크점수는 해당 웹페이지로 링크가 걸린 다른 웹페이지의 기본점수 ÷ 외부 링크 수의 - 총합이다. - 한 웹페이지의 매칭점수는 기본점수와 링크점수의 합으로 계산한다. 예를 들어, 다음과 같이 A, B, C 세 개의 웹페이지가 있고, 검색어가 hi라고 하자. **![example img](42893-example.jpg)** 이때 A 웹페이지의 매칭점수는 다음과 같이 계산할 수 있다. - 기본 점수는 각 웹페이지에서 hi가 등장한 횟수이다. - A,B,C 웹페이지의 기본점수는 각각 1점, 4점, 9점이다. - 외부 링크수는 다른 웹페이지로 링크가 걸린 개수이다. - A,B,C 웹페이지의 외부 링크 수는 각각 1점, 2점, 3점이다. - A 웹페이지로 링크가 걸린 페이지는 B와 C가 있다. - A 웹페이지의 링크점수는 B의 링크점수 2점(4 ÷ 2)과 C의 링크점수 3점(9 ÷ 3)을 더한 5점이 된다. - 그러므로, A 웹페이지의 매칭점수는 기본점수 1점 + 링크점수 5점 = 6점이 된다. 검색어 word와 웹페이지의 HTML 목록인 pages가 주어졌을 때, 매칭점수가 가장 높은 웹페이지의 index를 구하라. 만약 그런 웹페이지가 여러 개라면 그중 번호가 가장 작은 것을 구하라. --- ## 제한사항 - `pages`는 HTML 형식의 웹페이지가 문자열 형태로 들어있는 배열이고, 길이는 $1$ 이상 $20$ 이하이다. - 한 웹페이지 문자열의 길이는 $1$ 이상 $1,500$ 이하이다. - 웹페이지의 `index`는 `pages` 배열의 `index`와 같으며 $0$부터 시작한다. - 한 웹페이지의 `url`은 HTML의 태그 내에 태그의 값으로 주어진다. - 예를들어, 아래와 같은 meta tag 가 있으면 이 웹페이지의 url은 `https://careers.kakao.com/index` 이다. - `<meta property="og:url" content="https://careers.kakao.com/index" />` - 한 웹페이지에서 모든 외부 링크는 `<a href="https://careers.kakao.com/index">`의 형태를 가진다. - `<a>` 내에 다른 attribute가 주어지는 경우는 없으며 항상 href로 연결할 사이트의 url만 포함된다. - 위의 경우에서 해당 웹페이지는 `https://careers.kakao.com/index` 로 외부링크를 가지고 있다고 볼 수 있다. - 모든 url은 https:// 로만 시작한다. - 검색어 word는 하나의 영어 단어로만 주어지며 알파벳 소문자와 대문자로만 이루어져 있다. - word의 길이는 $1$ 이상 $12$ 이하이다. - 검색어를 찾을 때, 대소문자 구분은 무시하고 찾는다. - 예를들어 검색어가 blind일 때, HTML 내에 Blind라는 단어가 있거나, BLIND라는 단어가 있으면 두 경우 모두 해당된다. - 검색어는 단어 단위로 비교하며, 단어와 완전히 일치하는 경우에만 기본 점수에 반영한다. - 단어는 알파벳을 제외한 다른 모든 문자로 구분한다. - 예를들어 검색어가 "aba" 일 때, "abab abababa"는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다. - 만약 검색어가 "aba" 라면, "aba@aba aba"는 단어 단위로 세개가 일치하므로, 기본 점수는 3점이다. - 결과를 돌려줄때, 동일한 매칭점수를 가진 웹페이지가 여러 개라면 그중 index 번호가 가장 작은 것를 리턴한다 - 즉, 웹페이지가 세개이고, 각각 매칭점수가 3,1,3 이라면 제일 적은 index 번호인 0을 리턴하면 된다. --- ## 입출력 예 ### 예시 #1 - word : blind - pages : ```json [ "<html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n <meta charset=\"utf-8\">\n <meta property=\"og:url\" content=\"https://a.com\"/>\n</head> \n<body>\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \n<a href=\"https://b.com\"> Link to b </a>\n</body>\n</html>", "<html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n <meta charset=\"utf-8\">\n <meta property=\"og:url\" content=\"https://b.com\"/>\n</head> \n<body>\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \n<a href=\"https://a.com\"> Link to a </a>\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\n<a href=\"https://c.com\"> Link to c </a>\n</body>\n</html>", "<html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n <meta charset=\"utf-8\">\n <meta property=\"og:url\" content=\"https://c.com\"/>\n</head> \n<body>\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\n<a href=\"https://a.com\"> Link to a </a>\n</body>\n</html>" ] ``` - pages는 다음과 같이 3개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다. ```json <html lang="ko" xml:lang="ko" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta property="og:url" content="https://a.com"/></head><body> Blind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. <a href="https://b.com"> Link to b </a></body></html> ``` ```json <html lang="ko" xml:lang="ko" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta property="og:url" content="https://b.com"/></head><body> Suspendisse potenti. Vivamus venenatis tellus non turpis bibendum, <a href="https://a.com"> Link to a </a> blind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut. <a href="https://c.com"> Link to c </a></body></html> ``` ```json <html lang="ko" xml:lang="ko" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta property="og:url" content="https://c.com"/></head><body> Ut condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind <a href="https://a.com"> Link to a </a></body></html> ``` 위의 예를 가지고 각각의 점수를 계산해보자. - 기본점수 및 외부 링크수는 아래와 같다. - `a.com`의 기본점수는 3, 외부 링크 수는 1개 - `b.com`의 기본점수는 1, 외부 링크 수는 2개 - `c.com`의 기본점수는 1, 외부 링크 수는 1개 - 링크점수는 아래와 같다. - `a.com`의 링크점수는 b.com으로부터 0.5점, c.com으로부터 1점 - `b.com`의 링크점수는 a.com으로부터 3점 - `c.com`의 링크점수는 b.com으로부터 0.5점 - 각 웹 페이지의 매칭 점수는 다음과 같다. - `a.com` : 4.5 점 - `b.com` : 4 점 - `c.com` : 1.5 점 따라서 매칭점수가 제일 높은 첫번째 웹 페이지의 index인 0을 리턴 하면 된다. --- ### 예시 #2 - word : Muzi - pages : ```json [ "<html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n <meta charset=\"utf-8\">\n <meta property=\"og:url\" content=\"https://careers.kakao.com/interview/list\"/>\n</head> \n<body>\n<a href=\"https://programmers.co.kr/learn/courses/4673\"></a>#!MuziMuzi!)jayg07con&&\n\n</body>\n</html>", "<html lang=\"ko\" xml:lang=\"ko\" xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n <meta charset=\"utf-8\">\n <meta property=\"og:url\" content=\"https://www.kakaocorp.com\"/>\n</head> \n<body>\ncon%\tmuzI92apeach&2<a href=\"https://hashcode.co.kr/tos\"></a>\n\n\t^\n</body>\n</html>" ] ``` - pages는 다음과 같이 2개의 웹페이지에 해당하는 HTML 문자열이 순서대로 들어있다. ```json <html lang="ko" xml:lang="ko" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta property="og:url" content="https://careers.kakao.com/interview/list"/></head><body><a href="https://programmers.co.kr/learn/courses/4673"></a>#!MuziMuzi!)jayg07con&& </body></html> ``` ```json <html lang="ko" xml:lang="ko" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta property="og:url" content="https://www.kakaocorp.com"/></head><body> con% muzI92apeach&2<a href="https://hashcode.co.kr/tos"></a> ^ </body></html> ``` 위의 예를 가지고 각각의 점수를 계산해보자. - 기본점수 및 외부 링크수는 아래와 같다. - `careers.kakao.com/interview/list` 의 기본점수는 0, 외부 링크 수는 1개 - `www.kakaocorp.com` 의 기본점수는 1, 외부 링크 수는 1개 - 링크점수는 아래와 같다. - `careers.kakao.com/interview/list` 의 링크점수는 0점 - `www.kakaocorp.com` 의 링크점수는 0점 - 각 웹 페이지의 매칭 점수는 다음과 같다. - `careers.kakao.com/interview/list` : 0점 - `www.kakaocorp.com` : 1 점 따라서 매칭점수가 제일 높은 두번째 웹 페이지의 index인 1을 리턴 하면 된다. --- ## 풀이 과정 특별한 알고리즘이 필요하기보단 문자열 파싱을 잘 해야하는 문제라 별 고민 없이 코드를 작성했습니다. 먼저 아래와 같이 페이지 값을 파싱하는 함수를 작성했습니다. ```javascript const parsePage = (page, index, word) => { //페이지의 주소와 외부 링크는 정규식을 통해 찾을 수 있다 const url = page.match(/<meta property="og:url" content="(.+?)"/i)[1]; //페이지의 body 내용을 가져와 미리 소문자화한다 let body = page.match(/<body>([\w\W]+)<\/body>/i)[1].toLowerCase(); //replaceAll의 콜백 함수로 외부 링크를 수집하고 body에서 제거 const externalUrls = []; body = body.replaceAll(/<a href="(.+?)">/gi, (_, externalUrl) => { externalUrls.push(externalUrl); return ''; }); //앞뒤가 영문자가 아닌데, 단어와 일치하는 경우의 갯수를 기본 점수로 사용 const basePoint = (body.match(new RegExp(`[^a-z]${word}[^a-z]`, 'ig')) || []) .length; //파싱 결과를 객체로 반환 return { index, url, externalUrls, basePoint, totalPoint: basePoint }; }; ``` 그 후 페이지를 파싱한 결과를 Map에 담았습니다. 원래 배열을 사용하려고 했는데, 외부 링크 점수를 계산할 때 url을 키로 사용하기 위해 Map을 사용했습니다. 매핑이 끝난 후에 외부 링크 점수를 totalPoint에 더해 총 점수를 계산하고, 총점수를 기준으로 내림차순 정렬한 결과의 첫번째 요소의 인덱스를 반환했습니다. ```javascript function solution(word, pages) { //입력된 데이터 분석 후 매핑 const pageInfos = new Map( pages.map((page, index) => { const parsed = parsePage(page, index, word); return [parsed.url, parsed]; }) ); //외부 링크 점수 부여 처리 for (const page of pageInfos.values()) { const additionalPoint = page.basePoint / page.externalUrls.length; for (const externalUrl of page.externalUrls) { if (pageInfos.has(externalUrl)) { pageInfos.get(externalUrl).totalPoint += additionalPoint; } } } //총점수를 내림차순으로 정렬하고 첫번째 페이지의 인덱스를 반환 return [...pageInfos.values()].sort((a, b) => b.totalPoint - a.totalPoint)[0] .index; } ``` 하지만 이렇게 작성한 코드의 경우 입력 예제 2가지는 통과했지만, 테스트 케이스 1,2,9,12를 통과하지 못해 실패했습니다. 테스트케이스는 비공개이기 때문에 어떤 입력에 실패하는지 직접 찾아 해결해야만 했습니다. 때문에 문제에 적힌 모든 조건의 반례가 될만한 테스트 케이스를 직접 추가해서 실행해봤습니다. 그러던 중 문제 조건의 `예를들어 검색어가 "aba" 일 때, "abab abababa"는 단어 단위로 일치하는게 없으니, 기본 점수는 0점이 된다`라는 부분을 구현한 테스트 케이스를 추가한 순간 드디어 제 코드가 통과하지 못하는 테스트케이스를 찾게 되었습니다. 원인은 바로 기본 점수를 계산하는 부분에서 저지른 실수 때문이였습니다. ```javascript const basePoint = (body.match(new RegExp(`[^a-z]${word}[^a-z]`, 'ig')) || []) .length; ``` 단순히 body태그 내에는 최소한 단어 양쪽에 띄어쓰기라도 있을테니 앞뒤가 영문자가 아닌데, word와 일치하면 될거라고 생각했었는데, 이렇게 처리하는 경우 영문자 사이에 한글자만 존재하는 경우 다음 영문자를 그냥 넘어가는 경우가 발생했습니다. 예를 들어 `1abc2def3ghi4`라는 문자열에 대해 정규식 `/[^a-z][a-z]+[^a-z]/g` 를 처리하면 결과는 `['1abc2', '3ghi4']`입니다. `2def3`이 포함되지 않은 이유는 정규식이 아래와 같이 작동하기 때문입니다. | 처리중인 문자 | ... | 확인중인 문자열 | 남은 문자열 | | :-----------: | :----------------------- | :-------------- | :------------- | | `1` | `[^a-z]`일치 | `1` | `abc2def3ghi4` | | `a` | `[a-z]+`일치 | `1a` | `bc2def3ghi4` | | `b` | `[a-z]+`일치 | `1ab` | `c2def3ghi4` | | `c` | `[a-z]+`일치 | `1abc` | `2def3ghi4` | | `2` | `[^a-z]`일치 - 매칭 완료 | `1abc2` | `def3ghi4` | | | | | | | `d` | `[^a-z]`불일치 | | `ef3ghi4` | | `e` | `[^a-z]`불일치 | | `f3ghi4` | | `f` | `[^a-z]`불일치 | | `3ghi4` | | | | | | | `3` | `[^a-z]`일치 | `3` | `ghi4` | | `g` | `[a-z]+`일치 | `3g` | `hi4` | | `h` | `[a-z]+`일치 | `3gh` | `i4` | | `i` | `[a-z]+`일치 | `3ghi` | `4` | | `4` | `[^a-z]`일치 - 매칭 완료 | `3ghi4` | | 고래 싸움에 새우 def는 등이 터져버렸습니다! 이런 문제를 해결하기 위해 모든 영단어를 가져온 뒤 찾아야할 단어와 비교해 일치하는 횟수를 기본점수로 사용하도록 아래와 같이 수정했고, 이제 모든 테스트 케이스를 잘 통과합니다. ```javascript const basePoint = body .match(/[a-z]+/gi) .filter((match) => match === word.toLowerCase()).length; ``` 다른 분들은 저처럼 정규식을 잘 모르면서 정규식을 맹신하는 일이 없길 바랍니다... 이걸 몰라서 코드의 온갖 부분을 다 갈아 엎고 난리 쳤어요ㅠㅠ :::info 최종 코드 ```javascript const parsePage = (page, index, word) => { //페이지의 주소와 외부 링크는 정규식을 통해 찾을 수 있다 const url = page.match(/<meta property="og:url" content="(.+?)"/i)[1]; //페이지의 body 내용을 가져와 미리 소문자화한다 let body = page.match(/<body>([\w\W]+)<\/body>/i)[1].toLowerCase(); //replaceAll의 콜백 함수로 외부 링크를 수집하고 body에서 제거 const externalUrls = []; body = body.replaceAll(/<a href="(.+?)">/gi, (_, externalUrl) => { externalUrls.push(externalUrl); return ''; }); //body의 모든 영단어를 검사해 페이지의 기본 점수를 계산 const basePoint = body .match(/[a-z]+/gi) .filter((match) => match === word.toLowerCase()).length; return { index, url, externalUrls, basePoint, totalPoint: basePoint }; }; function solution(word, pages) { //입력된 데이터 분석 후 매핑 const pageInfos = new Map( pages.map((page, index) => { const parsed = parsePage(page, index, word); return [parsed.url, parsed]; }) ); //매핑된 데이터로 외부 링크 점수 부여 처리 for (const page of pageInfos.values()) { const additionalPoint = page.basePoint / page.externalUrls.length; for (const externalUrl of page.externalUrls) { if (pageInfos.has(externalUrl)) { pageInfos.get(externalUrl).totalPoint += additionalPoint; } } } //총점수를 내림차순으로 정렬하고 첫번째 페이지의 인덱스를 반환 return [...pageInfos.values()].sort((a, b) => b.totalPoint - a.totalPoint)[0] .index; } ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 12985 : 예상 대진표 - Javascript ]]></title><link>https://present.kim/posts/programmers/12985-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/12985-js</guid><description><![CDATA[ 프로그래머스 12985 : 예상 대진표 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-25T11:35:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 12985 : 예상 대진표](https://school.programmers.co.kr/learn/courses/30/lessons/12985) △△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, ... , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. **단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.** --- ## 제한사항 - N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.) - A, B : N 이하인 자연수 (단, A ≠ B 입니다.) --- ## 입출력 예 | N | A | B | | :-- | :-- | :-- | | 8 | 4 | 7 | - 예제 #1 첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다. --- ## 풀이 과정 - 시도 1 : 실제로 라운드 진행 (성공) 가장 단순하게 주어진대로 모든 라운드를 직접 진행해 결과를 찾는 방식으로 구현했습니다. 굉장히 비효율적이지만 실제로 잘 작동하고, 테스트 케이스도 모두 통과했습니다. ```javascript function solution(n, a, b) { //대진표 작성 //a와 b는 1, 나머지는 0으로 저장 const table = []; for (let i = 0; i < n; ++i) { table[i] = Number(a - 1 === i || b - 1 === i); } //0부터 n까지의 대진표를 순회한 후 n을 반으로 나누며 반복 진행 let round = 0; for (let i = n; n > 1; n /= 2) { round++; //라운드 결과는 덧셈으로 간단하게 계산 for (let j = 0; j < n; j += 2) { table[j / 2] = table[j] + table[j + 1]; //라운드 결과가 2인 경우 a와 b가 만난 것이므로 라운드를 반환 if (table[j / 2] === 2) { return round; } } } } ``` :::info $n=8, a=4, b=7$ 의 경우 진행 방식 | round | table | 설명 | | :---: | :----------------------: | :-----------------------: | | 0 | [0, 0, 0, 1, 0, 0, 1, 0] | `table` 배열 생성 | | 1 | [0, 1, 0, 1] | 라운드 진행 | | 2 | [1, 1] | 라운드 진행 | | **3** | [2] | **2가 되어 `round` 반환** | (table 배열의 1은 각각 a와 b를 의미합니다) ::: --- ## 풀이 과정 - 시도 2 : A와 B를 2로 나누며 비교 시도 1의 방식에서는 라운드가 진행 될 때마다 배열이 반으로 줄어들긴 하지만 의미없는 0값들에 대한 연산이 반복되기 때문에 굉장히 비효율적입니다. 사실상 모든 0은 의미가 없는 값이기 때문에 배열없이 효율적으로 a와 b만 이용해 라운드 값을 찾을 방법을 고민해봤습니다. 먼저 시도1에서 a와 b가 포함되지 않은 모든 라운드 계산이 의미가 없기 때문에 생략할 필요가 있습니다. 이를 위해 a와 b가 어떻게 이동하는지를 파악해보면 아래와 같습니다. :::info $n=8, a=4, b=7$ 의 경우 a와 b의 인덱스 변화 | round | a | b | | :---: | :----------------: | :----------------: | | 0 | 3 (4번째 선수) | 6 (7번째 선수) | | 1 | 1 (2번째 선수) | 3 (4번째 선수) | | 2 | 0 (1번째 선수) | 1 (2번째 선수) | | **3** | **0 (1번째 선수)** | **0 (1번째 선수)** | ::: a와 b가 라운드가 진행 될 때마다 2로 나눈 값의 올림으로 변경되고, 이 값이 같아질 때 라운드 결과를 반환하게 된다는 것을 파악했습니다. 그 후 이 방식대로 작동하도록 수정해 코드를 개선했습니다. 그 결과 테스트 케이스 실행 시간이 평균 11.92ms에서 0.04ms로 월등히 빨라졌습니다. 또한, 배열을 사용한 탓에 27~34번 테스트케이스에서 메모리 사용량이 30메가 더 증가하던 증상이 사라졌습니다. ```javascript function solution(n, a, b) { let round = 0; while (a !== b) { //a와 b가 같아질 때까지 반복 round++; //라운드 진행 //a와 b를 2로 나누고 올림 a = Math.ceil(a / 2); b = Math.ceil(b / 2); } return round; } ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 131702 : 고고학 최고의 발견 - Javascript ]]></title><link>https://present.kim/posts/programmers/131702-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/131702-js</guid><description><![CDATA[ 프로그래머스 131702 : 고고학 최고의 발견 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-23T23:48:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 131702 : 고고학 최고의 발견](https://school.programmers.co.kr/learn/courses/30/lessons/131702) 고고학자인 혜선은 오래전부터 성궤의 행방을 추적해왔습니다. 그동안 그의 연구는 주류 학자들로부터 인정받지 못했었지만, 혜선이는 포기하지 않고 조사를 계속했고 마침내 성궤의 행방을 알아내었습니다. 그러나 오래전 누군가로부터 봉인된 성궤는 특별한 잠금장치에 의해 보호되고 있었습니다. 잠금장치는 일종의 퍼즐과 연결되어 퍼즐을 해결하면 열리는 것으로 보입니다. 퍼즐은 시계들이 행렬을 이루는 구조물인데 하나의 시계에 시곗바늘은 하나씩만 있습니다. 각 시곗바늘은 시계방향으로만 돌릴 수 있고 한 번의 조작으로 90도씩 돌릴 수 있습니다. 시계들은 기계장치에 의해 연결되어 있어 어떤 시계의 시곗바늘을 돌리면 그 시계의 상하좌우로 인접한 시계들의 시곗바늘도 함께 돌아갑니다. 행렬의 모서리에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 세 시계의 시곗바늘들이 함께 돌아가며, 꼭짓점에 위치한 시계의 시곗바늘을 돌리는 경우에는 인접한 두 시계의 시곗바늘들이 함께 돌아갑니다. 각 시계는 12시, 3시, 6시, 9시 방향 중의 한 방향을 가리키고 있습니다. 각 시계의 시곗바늘을 적절히 조작하여 모든 시곗바늘이 12시 방향을 가리키면 퍼즐이 해결되어 성궤를 봉인하고 있는 잠금장치가 열릴 것입니다. 노후화된 퍼즐 기계장치가 걱정되었던 혜선은 가능한 최소한의 조작으로 퍼즐을 해결하려고 합니다. 시곗바늘들의 행렬 `clockHands`가 매개변수로 주어질 때, 퍼즐을 해결하기 위한 최소한의 조작 횟수를 return 하도록 solution 함수를 완성해주세요. --- ## 제한사항 - 2 ≤ `clockHands`의 길이 ≤ 8 - `clockHands`는 2차원 배열이며 행과 열의 크기가 동일합니다. - 0 ≤ `clockHands`의 원소 ≤ 3 - `clockHands[i]`의 원소들은 시곗바늘의 방향을 나타내며 0은 12시 방향, 1은 3시 방향, 2는 6시 방향, 3은 9시 방향을 나타냅니다. - 해결 가능한 퍼즐만 주어집니다. --- ## 입출력 예 | clockHands | result | | :---------------------------------------- | :----- | | [[0,3,3,0],[3,2,2,3],[0,3,2,0],[0,3,3,3]] | 3 | - 예제 #1 2행 2열의 시곗바늘, 2행 3열의 시곗바늘, 4행 3열의 시곗바늘을 각각 한 번씩 돌리면 최소 조작 횟수로 퍼즐을 해결할 수 있습니다. ![example img](131702-example.png) --- ## 풀이 과정 - 시도 1 : 풀(?) 완전 탐색 (실패) 처음에는 단순히 모든 경우의 수를 대입해서 가장 낮은 횟수를 구하는 완전 탐색의 풀이로 해결할 수 있을 것 같았습니다. 그래서 먼저 이 방식으로 풀어보니 $n < 4$일 때 시간 초과가, $n>=4$일 때는 아예 `signal: aborted (core dumped)` 오류가 발생해 실패했습니다. 검색해보니 해당 오류의 경우 메모리 범위를 벗어나거나, 자바스크립트 배열의 최대 크기인 $2^{32}-1$을 초과할 경우 발생한다는 답변이 있었습니다. :::danger 모든 경우의 수를 만들기 위해 작성된 문제의 함수 ```javascript const createAllCases = (count, arr = [], acc = []) => { if (arr.length == count * count) { const result = []; for (let i = 0; i < count; ++i) { result.push(arr.slice(i * count, (i + 1) * count)); } acc.push(result); return; } for (let i = 0; i < 4; ++i) { arr.push(i); createAllCases(count, arr, acc); arr.pop(); } return acc; }; ``` ::: 이런 문제가 발생하는 이유가 궁금해 경우의 수를 계산해보니 $n*n$ 행렬에 0~3를 대입하는 경우의 수는 무려 $4^{n*n}$으로, "와 보기만해도 n이 조금만 커져도 난리 나겠네..." 싶었습니다. 직접 계산을 해봐도 입출력 예와 같이 $n=4$의 작은 행렬에서도 $4^{16}$개의 경우의 수가 나오고, 최대 크기인 $n=8$의 경우 $4^{64}$로 무려 39자리의 읽기도 힘든 긴 수가 나왔습니다. 문제의 입력 범위와 풀이의 실행 시간을 미리 생각해보지 않은 제 실수였습니다... - $n = 2\ \Rightarrow\ 4^{2*2}\ =\ 256$ - $n = 4\ \Rightarrow\ 4^{4*4}\ =\ 4,294,967,296$ - $n = 8\ \Rightarrow\ 4^{8*8}\ =\ 340,282,366,920,938,463,463,374,607,431,768,211,456$ 🤯 - 심지어 재귀 함수로 구현했고, 함수의 호출이나 로직 등의 모든 부분을 무시하더라도 경우의 수를 만들 때 마다 $n*n$의 행렬을 복사해야한다는 기본 전제가 존재하기 때문에 이보다 더한 연산 횟수가 필요한 셈이죠... --- ## 풀이 과정 - 시도 2 : 첫 줄만 완전 탐색 (성공) 이 문제를 해결하기 위해 많은 시행착오 끝에 문제에서 찾을 수 있는 여러 규칙을 정리하고 경우의 수를 줄여보았습니다. 1. 시곗바늘을 회전시키는 순서가 바뀌어도 각 시곗바늘의 회전 수가 같기 때문에 결과가 동일합니다 2. $(x, y)$의 시곗바늘이 회전하면 $(x, y - 1)$의 시곗바늘도 회전합니다 1번 조건을 이용해 경우의 수 탐색을 한 열씩 차례대로 진행하기로 정했습니다 이렇게 한 열씩 차례대로 진행할 경우 $y$열의 탐색이 끝나면 $y$열의 시곗바늘을 수정할 수 있는 것은 $y+1$열의 같은 행의 시곗바늘 뿐입니다 따라서 $y+1$열에서 $y$열의 행을 0으로 만들지 못하는 행의 값은 생략해도 됩니다. 최종 문제 풀이 방식은 아래와 같습니다. 1. 첫째 열에 들어갈 수 있는 모든 경우의 수를 구한다 : $O(4^n)$ 2. 복사한 행렬을 대상으로 나머지 열에 들어갈 수 있는 모든 경우의 수를 구한다 : $O(n^2)$ 위 방식대로 진행할 경우 탐색할 경우의 수는 $4^n * n^2$입니다. - $n = 2\ \Rightarrow\ 4^{2} *\ 2^2\ =\ 64$ - $n = 4\ \Rightarrow\ 4^{4} *\ 4^2\ =\ 4,096$ - $n = 8\ \Rightarrow\ 4^{8} *\ 8^2\ =\ 4,194,304$ 😆 :::info 개선된 코드 전문 ```javascript //2차원 배열의 깊은 복사를 수행하는 함수 const deepcopy = (arr) => arr.map((v) => v.slice()); //주어진 clockHands의 [x, y]와 인접한 시곗바늘을 회전 시키는 함수 const rotateHand = (x, y, clockHands, rotate) => { //십자 형태로 탐색하기 위한 x, y 방향 값 const dx = [0, -1, 1, 0, 0]; const dy = [0, 0, 0, -1, 1]; for (let i = 0; i < 5; i++) { const nx = x + dx[i]; const ny = y + dy[i]; if (clockHands[ny] !== undefined && clockHands[ny][nx] !== undefined) { clockHands[ny][nx] = (clockHands[ny][nx] + rotate) % 4; } } }; //첫째 열에 대한 모든 경우의 수를 생성하는 함수 (4 ** n 개) //빠른 생성을 위해 캐시 배열을 사용합니다 //spead 연산자를 이용해 항상 새 배열을 만들기 때문에 deepcopy를 사용할 필요는 없습니다. const caseCache = [, [[0], [1], [2], [3]]]; const createFirstRowCases = (count) => { const results = []; for (let i = 0; i < 4; ++i) { const permutations = caseCache[count - 1] ?? createFirstRowCases(count - 1); const attached = permutations.map((permutation) => [i, ...permutation]); results.push(...attached); } return (caseCache[count] = results); }; //나머지 열은 바로 위 열을 기준으로 회전 시키고 성공 시 시도 횟수를 반환하는 함수 const tryOtherRows = (clockHands, count) => { const length = clockHands.length; for (let y = 1; y < length; ++y) { for (let x = 0; x < length; ++x) { const rotate = 4 - clockHands[y - 1][x]; if (rotate === 4) { continue; } rotateHand(x, y, clockHands, rotate); count += rotate; } } if (clockHands[length - 1].every((el) => el === 0)) { return count; } return null; }; function solution(originClockHands) { const length = originClockHands.length; let answer = Number.MAX_SAFE_INTEGER; createFirstRowCases(length).forEach((firstRow) => { let count = 0; const clockHands = deepcopy(originClockHands); firstRow.forEach((rotate, x) => { rotateHand(x, 0, clockHands, rotate); count += rotate; }); count = tryOtherRows(clockHands, count); if (count !== null) { answer = Math.min(answer, count); } }); return answer; } ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 120956 : 옹알이 - Javascript ]]></title><link>https://present.kim/posts/programmers/120956-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/120956-js</guid><description><![CDATA[ 프로그래머스 120956 : 옹알이 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-04T12:13:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 120956 : 옹알이](https://school.programmers.co.kr/learn/courses/30/lessons/120956) 머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 조카는 아직 "aya", "ye", "woo", "ma" 네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 문자열 배열 `babbling`이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요. --- ## 제한사항 - - 1 ≤ `babbling`의 길이 ≤ 100 - 1 ≤ `babbling[i]`의 길이 ≤ 15 - `babbling`의 각 문자열에서 "aya", "ye", "woo", "ma"는 각각 최대 한 번씩만 등장합니다. - 즉, 각 문자열의 가능한 모든 부분 문자열 중에서 "aya", "ye", "woo", "ma"가 한 번씩만 등장합니다. - 문자열은 알파벳 소문자로만 이루어져 있습니다. --- ## 입출력 예 | babbling | result | | :------------------------------------------ | :----- | | ["aya", "yee", "u", "maa", "wyeoo"] | 1 | | ["ayaye", "uuuma", "ye", "yemawoo", "ayaa"] | 3 | - 예제 #1 ["aya", "yee", "u", "maa", "wyeoo"]에서 발음할 수 있는 것은 "aya"뿐입니다. 따라서 1을 return합니다 - 예제 #2 ["ayaye", "uuuma", "ye", "yemawoo", "ayaa"]에서 발음할 수 있는 것은 "aya" + "ye" = "ayaye", "ye", "ye" + "ma" + "woo" = "yemawoo"로 3개입니다. 따라서 3을 return합니다. --- ## 유의사항 네 가지를 붙여 만들 수 있는 발음 이외에는 어떤 발음도 할 수 없는 것으로 규정합니다. 예를 들어 "woowo"는 "woo"는 발음할 수 있지만 "wo"를 발음할 수 없기 때문에 할 수 없는 발음입니다. --- ## 풀이 과정 그냥 보이는 대로 발음 가능한 단어를 제거하는 방식을 사용하면 예제에 있는 "wyeoo"를 처리할 때 "ye"를 제거하고, 그 다음 "woo"를 제거해 발음이 가능하다고 처리하기 때문에 단어를 유지한 채로 모두 발음이 가능한지 확인해야합니다. 제가 생각한 해결 방법은 단어는 그대로 두고, 단어의 길이만 구해서 발음이 가능할 경우 길이를 줄여 길이가 0이 되면 발음이 가능한 단어라고 처리하는 것입니다. 문제 조건 중 모든 발음은 한번씩만 가능하다고 했기 때문에 여러번 포함되는 경우는 생각하지 않아도 됩니다. ```javascript //조카가 가능한 발음 목록 const pronunciations = ['aya', 'ye', 'woo', 'ma']; function solution(babbling) { let answer = 0; for (const word of babbling) { //남은 단어의 길이 let remain = word.length; for (const pronunce of pronunciations) { //가능한 발음이 포함되면 해당 발음의 길이만큼 남은 길이를 줄임 if (word.includes(pronunce)) { remain -= pronunce.length; } } //남은 길이가 없으면 발음 가능한 단어 if (remain === 0) { answer++; } } return answer; } ``` ]]></content:encoded></item><item><title><![CDATA[ 🧮 알고리즘 : 누적합 (Prefix sum) ]]></title><link>https://present.kim/posts/argorithm/prefix-sum</link><guid isPermaLink="false">https://present.kim/posts/argorithm/prefix-sum</guid><description><![CDATA[ 배열이 주어졌을 때 특정 구간의 합을 반복해서 구해야하는 경우에 사용할 수 있는 알고리즘 ]]></description><pubDate>2023-02-04T01:40:00.000Z</pubDate><content:encoded><![CDATA[ **![time-limit-exceeded.png](prefix-sum_time-limit-exceeded.png) _! TIME LIMIT EXCEEDED !_** 알고리즘 문제를 풀다보면 단순히 반복 수행하면 시간 초과에 걸리게 되는 유형의 문제가 많이 나타납니다. 요구하는 결과를 찾는 로직을 열심히 구현한 뒤에 _"오 드디어 구해진다!"_ 하고 제출했는데, **`시간 초과`**라고 뜨면 굉장히 머리가 아파지죠. 오늘은 부분합, 구간합 문제에 주로 사용되는 **`누적합`(Prefix sum)**에 대해 알아보도록 하겠습니다. --- ## ❔ 부분합, 구간합 ${(Partial\ Sum)}$ 먼저 간단하게 부분합과 구간합에 대해 알아봅시다. - 부분합 `0 ~ n`: 수열(배열)의 $0$번째부터 $n-1$번째까지의 합입니다. - 수학식 : $S_n = a_1 + a_2 + a_3 + \dotsc + a_n$ - 프로그래밍식 : `S(n) = a[0] + a[1] + a[2] + ... + a[n-1]` - 구간합 `a ~ b` : 수열(배열)의 $a$번째부터 $b$번째까지의 합입니다. - 수학식 : $S_{(a,b)} = a_a + a_{a+1} + \dotsc + \dot + a_{b-2} + a_{b-1} + a_b$ - 프로그래밍식 : `S(a, b) = a[a] + a[a+1] + ... + a[b-1] + a[b]` --- ## ❔ 누적합 $(Prefix\ Sum)$ | $array$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $...$ | | :-----------: | :-: | :-: | :-: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | | $prefix\ sum$ | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ | $45$ | $...$ | _자연수가 나열된 1차원 수열 $(array)$이 있을 때 이 수열에 대한 누적합 $(prefix\ sum)$_ 누적합은 나열된 수(수열)의 누적된 합 자체 혹은 그것을 담은 수열을 의미합니다. 또한, 누적합의 각 요소는 수열의 $n$번째까지 요소의 합이기 때문에 수열의 부분합이라고 할 수 있습니다. 자 그럼 누적합은 어떤 경우에 사용하기 위해서 만들어진 걸까요? 누적합 방식은 아래 유형의 문제 해결에 주로 사용됩니다. - 구간합 / 부분합 ${(Partial\ Sum)}$ - 카운팅 정렬 $(Counting Sort)$ 이제 1차원 수열과 2차원 수열로 나누어 예시를 보며 어떻게 만들고 사용하는지 배워봅시다. --- ### 🧪 1차원 배열에서의 누적합 1차원 배열의 누적합을 만드는 방법은 아주 간단합니다. 1. 같은 크기의 배열을 만듭니다. 2. 해당 인덱스까지의 총합을 담습니다. 자바스크립트에선 아래와 같이 작성할 수 있습니다. ```javascript function prefixSums(arr) { const len = arr.length; const prefixSums = []; let sum = 0; for (let i = 0; i < len; ++i) { sum += arr[i]; prefixSums[i] = sum; } return prefixSums; } ``` 만약 `sum`변수를 만들지 않고 싶다면 아래와 같이 작성할 수 있습니다. ```javascript function prefixSums(arr) { const len = arr.length; const prefixSums = [arr[0]]; for (let i = 1; i < len; ++i) { prefixSums[i] = prefixSums[i - 1] + arr[i]; } return prefixSums; } ``` #### 🥇 문제 풀이에 사용해보기 백준의 대표적인 구간합 문제인 [`백준 11659 : 구간 합 구하기 4`](https://www.acmicpc.net/problem/11659)입니다. > ### 문제 > > 수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오. > > ### 입력 > > 첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. > 둘째 줄에는 N개의 수가 주어진다. > 수는 1,000보다 작거나 같은 자연수이다. > 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다. > > ### 출력 > > 총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다. > > ### 제한 > > - 1 ≤ N ≤ 100,000 > - 1 ≤ M ≤ 100,000 > - 1 ≤ i ≤ j ≤ N > > :::boj-input 예제 입력 > > ```text > > 5 3 > 5 4 3 2 1 > 1 3 > 2 4 > 5 5 > ``` > > ::: > > :::boj-output 예제 출력 > > ```text > > 12 > 9 > 1 > ``` > > ::: --- ## 🚀 누적합의 목적 자 그럼 누적합은 어떤 경우에 사용하기 위해서 만들어진 걸까요? 알고리즘 문제를 예시로 들면 아래 유형의 문제에 주로 사용됩니다. - 구간합 / 부분합 ${(Partial\ Sum)}$ - 카운팅 정렬 $(Counting Sort)$ 백준의 대표적인 구간합 문제인 [`백준 11659 : 구간 합 구하기 4`](https://www.acmicpc.net/problem/11659)를 예시로 풀어보도록 하겠습니다. --- ## 참고 문헌 - [wikipedia.org/wiki/Prefix_sum](https://en.wikipedia.org/wiki/Prefix_sum) ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 1845 : 폰켓몬 - Javascript ]]></title><link>https://present.kim/posts/programmers/1845-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/1845-js</guid><description><![CDATA[ 프로그래머스 1845 : 폰켓몬 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-02T18:21:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 1845 : 폰켓몬](https://school.programmers.co.kr/learn/courses/30/lessons/1845) 당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 1. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 2. 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 3. 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 4. 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 5. 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 6. 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. --- ## 제한사항 - nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. - nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. - 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. - 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다. --- ## 입출력 예 | nums | result | | :------------ | :----- | | [3,1,2,3] | 2 | | [3,3,3,2,2,4] | 3 | | [3,3,3,2,2,2] | 2 | - 예제 #1 문제의 예시와 같습니다. - 예제 #2 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다. - 예제 #3 6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다. --- ## 풀이 과정 먼저 모든 폰켓몬의 종류가 다르자면 N/2마리를 가지는 것이 가장 많은 종류의 폰켓몬을 고르는 방법입니다. 하지만 폰켓몬의 종류 수가 N/2마리보다 적다면 모든 폰켓몬 종류를 선택하는 것이 가장 많은 종류의 폰켓몬을 고르는 방법이 됩니다. 따라서 `N/2`와 `폰켓몬 종류의 수` 중 더 작은 값을 반환하면 됩니다. ### 시도 1 모든 폰켓몬을 해쉬맵에 담아 `폰켓몬 종류의 수`를 구합니다. ```javascript function solution(nums) { const map = {}; for (const num of nums) { map[num] = true; } const max = nums.length / 2; const types = Object.values(map).length; return Math.min(max, types); } ``` --- ### 시도 2 모든 폰켓몬 `Set`에 담아 빠르게 `폰켓몬 종류의 수`를 구합니다. - `Set`은 같은 값은 하나만 갖는 컬렉션 객체입니다. ```javascript function solution(nums) { const max = nums.length / 2; const types = new Set(nums).size; return Math.min(max, types); } ``` --- ## 숏코딩 (CodeGolf) 조금 더 코드를 간결하게 바꾸기 위해 람다식으로 변경해 아래와 같이 정리할 수 있습니다. ```c const solution = (nums) => Math.min(nums.length / 2, new Set(nums).size); ``` --- 마지막으로 가독성을 포기하고 모든 이름을 한글자로 수정하면 아래와 같이 숏코딩 코드가 완성됩니다. ```c solution=n=>Math.min(n.length/2,new Set(n).size) ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 152995 : 인사고과 - Javascript ]]></title><link>https://present.kim/posts/programmers/152995-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/152995-js</guid><description><![CDATA[ 프로그래머스 152995 : 인사고과 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-02T16:29:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 152995 : 인사고과](https://school.programmers.co.kr/learn/courses/30/lessons/152995) 완호네 회사는 연말마다 1년 간의 인사고과에 따라 인센티브를 지급합니다. 각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있는데 만약 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한 번이라도 있다면 그 사원은 인센티브를 받지 못합니다. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급됩니다. 이때, 두 점수의 합이 동일한 사원들은 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터입니다. 각 사원의 근무 태도 점수와 동료 평가 점수 목록 scores이 주어졌을 때, 완호의 석차를 return 하도록 solution 함수를 완성해주세요. --- ## 제한사항 - 1 ≤ `scores`의 길이 ≤ 100,000 - `scores`의 각 행은 한 사원의 근무 태도 점수와 동료 평가 점수를 나타내며 [a, b] 형태입니다. - `scores`[0]은 완호의 점수입니다. - 0 ≤ a, b ≤ 100,000 - 완호가 인센티브를 받지 못하는 경우 -1을 return 합니다. --- ## 입출력 예 | scores | result | | :------------------------------ | :----- | | [[2,2],[1,4],[3,2],[3,2],[2,1]] | 4 | - 5 번째 사원은 3 번째 또는 4 번째 사원보다 근무 태도 점수와 동료 평가 점수가 모두 낮기 때문에 인센티브를 받을 수 없습니다. - 2 번째 사원, 3 번째 사원, 4 번째 사원은 두 점수의 합이 5 점으로 최고점이므로 1 등입니다. - 1 등이 세 명이므로 2 등과 3 등은 없고 1 번째 사원인 완호는 두 점수의 합이 4 점으로 4 등입니다. --- ## 풀이 과정 전체 선수(participant) 중 완주한 선수(completion) 목록에 존재하지 않는 선수 한 명을 찾아내야 합니다. --- ### 시도 1 `splice`와 `indexOf`를 이용해 완주한 선수(completion)를 전체 선수(participant)에서 하나씩 소거한 뒤, 남은 한 선수의 이름을 반환하는 방식으로 풀어봤습니다. ```javascript function solution(scores) { const len = scores.length; for(let i = 1; i < len; ++i){ if(scores[0][1] < scores[i][0] && scores[0][1] < scores[i][1]){ return -1; } } const totalScores = scores.map([a,b] => a + b); } ``` 하지만 정확도 테스트는 통과하고 시간 초과로 효율성 테스트는 통과하지 못했습니다. 배열을 수정하는 `splice`가 느리기 때문에 생긴 문제인 듯 합니다. --- ### 시도 2 아래와 같이 해쉬를 이용해 문제를 다시 풀었고, 성공적으로 효율성 테스트까지 통과했습니다. ```javascript function solution(participant, completion) { // 완주한 선수의 이름의 개수를 저장할 변수 선언 const counts = {}; // 완주한 선수의 이름의 개수를 `counts` 변수에 담기 for (name of completion) { if (counts[name]) { counts[name]++; } else { counts[name] = 1; } } for (name of participant) { if (counts[name]) { counts[name]--; // 선수 이름이 있으면 개수 1 감소 } else { return name; // 선수 이름이 없거나 0이면 해당 선수의 이름을 반환 } } } ``` --- ## 숏코딩 (CodeGolf) 조금 더 코드를 간결하게 바꾸기 위해 조건식 부분을 수정해 아래와 같이 정리 가능합니다. ```javascript function solution(participant, completion) { const counts = {}; for (name of completion) counts[name] = (counts[name] | 0) + 1; for (name of participant) if (!counts[name]--) return name; } ``` :::help `counts`에 `name`이 없을 수도 있는데 `!counts[name]--`이 왜 제대로 작동하나요? 1. `counts[name]`가 비어있을 경우 접근하면 `undefined`를 반환합니다. 2. `undefined`가 산술 연산자와 만나면 오류 없이 `NaN`으로 바뀌게 됩니다. 3. `NaN`은 논리값 거짓으로 변환되기 때문에, `!NaN`은 `true`로 변환됩니다. - 따라서 `counts[name]`이 존재하지 않을 때, `!counts[name]--`는 `true`으로 변환됩니다. 이러한 과정을 통해 매핑된 값이 없는 경우에도 선수의 이름을 반환하는 로직이 정상적으로 작동하게 됩니다. ::: --- 추가로 `counts` 객체 생성 라인을 제거하고 `completion` 배열을 해쉬맵 용도로 재사용합니다. ```javascript function solution(participant, completion) { for (name of completion) completion[name] = (completion[name] | 0) + 1; for (name of participant) if (!completion[name]--) return name; } ``` :::help `completion`는 배열인데 어떻게 키값을 인덱스로 사용 할 수 있나요? - 자바스크립트에서는 배열 또한 `Array`라는 객체이기 때문에 속성(property)을 추가할 수가 있습니다. - 따라서 `completion[name]`이라는 코드가 정상적으로 작동하게 됩니다. ::: --- `for-of`를 `map()`과 `find()` 메소드로 바꾸고 한줄의 코드로 합칩니다. ```javascript function solution(participant, completion) { completion.map((name) => (completion[name] = (completion[name] | 0) + 1)); return participant.find((name) => !completion[name]--, completion); } ``` ```javascript solution = (participant, completion) => participant.find( (name) => !completion[name]--, completion.map((name) => (completion[name] = (completion[name] | 0) + 1)) ); ``` --- 마지막으로 가독성을 포기하고 모든 이름을 한글자로 수정하면 아래와 같이 숏코딩 코드가 완성됩니다. ```javascript solution = (p, c) => p.find( (n) => !c[n]--, c.map((n) => (c[n] = (c[n] | 0) + 1)) ); ``` ]]></content:encoded></item><item><title><![CDATA[ 🏅 프로그래머스 42576 : 완주하지 못한 선수 - Javascript ]]></title><link>https://present.kim/posts/programmers/42576-js</link><guid isPermaLink="false">https://present.kim/posts/programmers/42576-js</guid><description><![CDATA[ 프로그래머스 42576 : 완주하지 못한 선수 문제를 Javascript로 풀이한 내용입니다. ]]></description><pubDate>2023-02-02T16:29:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 설명 - 출처: [프로그래머스 42576 : 완주하지 못한 선수](https://school.programmers.co.kr/learn/courses/30/lessons/42576) 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. --- ## 제한사항 - 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. - completion의 길이는 participant의 길이보다 1 작습니다. - 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. - 참가자 중에는 동명이인이 있을 수 있습니다. --- ## 입출력 예 | participant | completion | return | | :------------------------------------------------ | :--------------------------------------- | :------- | | ["leo", "kiki", "eden"] | ["eden", "kiki"] | "leo" | | ["marina", "josipa", "nikola", "vinko", "filipa"] | ["josipa", "filipa", "marina", "nikola"] | "vinko" | | ["mislav", "stanko", "mislav", "ana"] | ["stanko", "ana", "mislav"] | "mislav" | - 예제 #1 "leo"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. - 예제 #2 "vinko"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. - 예제 #3 "mislav"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. --- ## 풀이 과정 전체 선수(participant) 중 완주한 선수(completion) 목록에 존재하지 않는 선수 한 명을 찾아내야 합니다. --- ### 시도 1 `splice`와 `indexOf`를 이용해 완주한 선수(completion)를 전체 선수(participant)에서 하나씩 소거한 뒤, 남은 한 선수의 이름을 반환하는 방식으로 풀어봤습니다. ```javascript function solution(participant, completion) { // 전체 선수 목록에서 완주한 선수의 이름을 하나씩 소거 for (name of completion) { participant.splice(participant.indexOf(name), 1); } // 전체 선수 목록에서 남아있는 선수의 이름을 반환 return participant[0]; } ``` 하지만 정확도 테스트는 통과하고 시간 초과로 효율성 테스트는 통과하지 못했습니다. 배열을 수정하는 `splice`가 느리기 때문에 생긴 문제인 듯 합니다. --- ### 시도 2 아래와 같이 해쉬를 이용해 문제를 다시 풀었고, 성공적으로 효율성 테스트까지 통과했습니다. ```javascript function solution(participant, completion) { // 완주한 선수의 이름의 개수를 저장할 변수 선언 const counts = {}; // 완주한 선수의 이름의 개수를 `counts` 변수에 담기 for (name of completion) { if (counts[name]) { counts[name]++; } else { counts[name] = 1; } } for (name of participant) { if (counts[name]) { counts[name]--; // 선수 이름이 있으면 개수 1 감소 } else { return name; // 선수 이름이 없거나 0이면 해당 선수의 이름을 반환 } } } ``` --- ## 숏코딩 (CodeGolf) 조금 더 코드를 간결하게 바꾸기 위해 조건식 부분을 수정해 아래와 같이 정리 가능합니다. ```javascript function solution(participant, completion) { const counts = {}; for (name of completion) counts[name] = (counts[name] | 0) + 1; for (name of participant) if (!counts[name]--) return name; } ``` :::help `counts`에 `name`이 없을 수도 있는데 `!counts[name]--`이 왜 제대로 작동하나요? 1. `counts[name]`가 비어있을 경우 접근하면 `undefined`를 반환합니다. 2. `undefined`가 산술 연산자와 만나면 오류 없이 `NaN`으로 바뀌게 됩니다. 3. `NaN`은 논리값 거짓으로 변환되기 때문에, `!NaN`은 `true`로 변환됩니다. - 따라서 `counts[name]`이 존재하지 않을 때, `!counts[name]--`는 `true`으로 변환됩니다. 이러한 과정을 통해 매핑된 값이 없는 경우에도 선수의 이름을 반환하는 로직이 정상적으로 작동하게 됩니다. ::: --- 추가로 `counts` 객체 생성 라인을 제거하고 `completion` 배열을 해쉬맵 용도로 재사용합니다. ```javascript function solution(participant, completion) { for (name of completion) completion[name] = (completion[name] | 0) + 1; for (name of participant) if (!completion[name]--) return name; } ``` :::help `completion`는 배열인데 어떻게 키값을 인덱스로 사용 할 수 있나요? - 자바스크립트에서는 배열 또한 `Array`라는 객체이기 때문에 속성(property)을 추가할 수가 있습니다. - 따라서 `completion[name]`이라는 코드가 정상적으로 작동하게 됩니다. ::: --- `for-of`를 `map()`과 `find()` 메소드로 바꾸고 한줄의 코드로 합칩니다. ```javascript function solution(participant, completion) { completion.map((name) => (completion[name] = (completion[name] | 0) + 1)); return participant.find((name) => !completion[name]--, completion); } ``` ```javascript solution = (participant, completion) => participant.find( (name) => !completion[name]--, completion.map((name) => (completion[name] = (completion[name] | 0) + 1)) ); ``` --- 마지막으로 가독성을 포기하고 모든 이름을 한글자로 수정하면 아래와 같이 숏코딩 코드가 완성됩니다. ```c solution=(p,c)=>p.find(n=>!c[n]--,c.map(n=>(c[n]=(c[n]|0)+1))) ``` ]]></content:encoded></item><item><title><![CDATA[ 📝 mdsvex에 정보 블럭을 추가했어요 ]]></title><link>https://present.kim/posts/blog/remark-admonitions</link><guid isPermaLink="false">https://present.kim/posts/blog/remark-admonitions</guid><description><![CDATA[ ]]></description><pubDate>2022-12-02T17:47:00.000Z</pubDate><content:encoded><![CDATA[ 블로그에 [remark-admonitions](https://www.npmjs.com/package/remark-admonitions)를 추가했습니다. 이제 블로그 포스트에서 아래와 같은 문법으로 정보 블럭을 사용할 수 있습니다. ```markdown \:::{type} {Title} {Something} \::: ``` --- ## Default Hint Block :::info Information `info` : 일반 정보나 팁 정보 ::: :::help Helpppppp `help` : 안내 사항이나 도움말 ::: :::warning Warning `warning` : 약한 경고나 주의사항 ::: :::danger Dangerous `danger` : 강한 경고나 금지사항 ::: :::success Success :smile: `success` : 성공이나 정답 긍정적인 내용 ::: :::failure Failure :cry: `failure` : 실패나 오답 부정적인 내용 ::: --- ## BOJ Hint Block :::boj-input 예제 입력 ::: :::boj-output 예제 출력 ```text Hello World! ``` ::: :::boj-code PHP ```php <? echo "Hello World!"; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 10926 : ??! (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/10926</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/10926</guid><description><![CDATA[ 백준 10926 : ??! 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-09T11:11:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오. ## 입력 첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다. ## 출력 첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다. :::boj-input 예제 입력 1 joonas ::: :::boj-output 예제 출력 1 joonas??! ::: :::boj-input 예제 입력 2 baekjoon ::: :::boj-output 예제 출력 2 baekjoon??! ::: ## 알고리즘 분류 - 구현 --- ## 풀이 :::boj-code PHP ```php <? echo trim(fgets(STDIN)) . "??!"; ``` ::: :::boj-code CPP ```cpp #include<ios> int main(){ char s[51]; scanf("%s", s); printf("%s??!", s); return 0; } ``` ::: ## 숏코딩 풀이 출력이 하나일땐 `<?=`태그가 더 편하다. ?>로 태그를 닫은 후에 적는 코드는 그대로 출력이 되는 점을 이용해 더 짧게 작성할 수 있다. :::boj-code PHP ```php <?=trim(fgets(STDIN))?>??! ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 10869 : 사칙연산 (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/10869</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/10869</guid><description><![CDATA[ 백준 10869 : 사칙연산 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-09T11:02:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A\*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오. ## 입력 두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000) ## 출력 첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A\*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다. :::boj-input 예제 입력 7 3 ::: :::boj-input 예제 출력 10 4 21 2 1 ::: ## 알고리즘 분류 - 수학 - 구현 - 사칙연산 --- ## 풀이 한줄로 입력된 두 숫자를 구하고 결과를 출력한다 :::boj-code PHP ```php <? fscanf(STDIN, "%d%d", $a, $b); echo $a + $b . PHP_EOL; echo $a - $b . PHP_EOL; echo $a * $b . PHP_EOL; echo intdiv($a, $b) . PHP_EOL; echo $a % $b; ``` ::: :::boj-code CPP ```cpp #include <ios> int main(){ int a, b; scanf("%d %d", &a, &b); printf("%d\n%d\n%d\n%d\n%d", a + b, a - b, a * b, a / b, a % b); return 0; } ``` ::: ## 숏코딩 풀이 더 코드를 줄일 방법이 생각나지 앉아서 그냥 공백만 제거했다 :::boj-code PHP ```php <?fscanf(STDIN,"%d%d",$a,$b);printf("%d %d %d %d %d",$a+$b,$a-$b,$a*$b,$a/$b,$a%$b); ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 1008 : A/B (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/1008</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/1008</guid><description><![CDATA[ 백준 1008 : A/B 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-04T14:02:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오. ## 입력 첫째 줄에 A와 B가 주어진다. (0 〈 A, B 〈 10) ## 출력 첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다. :::boj-input 예제 입력 1 1 3 ::: :::boj-output 예제 출력 1 0.33333333333333333333333333333333 ::: :::boj-input 예제 입력 2 4 5 ::: :::boj-output 예제 출력 2 0.8 ::: ## 알고리즘 분류 - 수학 - 구현 - 사칙연산 --- ## 풀이 한줄로 입력된 두 숫자를 구하고 결과를 출력한다 :::boj-code PHP ```php <? fscanf(STDIN, "%d %d", $a, $b); echo $a / $b; ``` ::: 출력 소수 자릿수가 9개 이상 나와야하기 때문에 `iomanip`의 `setprecision`을 사용해야한다 :::boj-code CPP ```cpp #include <iostream> #include <iomanip> using namespace std; int main(){ double a, b; cin >> a >> b; cout << setprecision(9) << a / b; return 0; } ``` ::: > 사실 그냥 `scanf`와 `printf`를 사용하는 방법이 더 간단하다 > > :::boj-code CPP ````cpp > #include <ios> > > int main(){ > double a, b; > scanf("%lf %lf", &a, &b); > printf("%.9lf", a / b); > > return 0; > } > ``` ::: :::boj-code JavaScript ```JavaScript const fs = require('fs'); const inputData = fs.readFileSync(0, 'utf8').toString().split(' '); const a = parseInt(inputData[0]), b = parseInt(inputData[1]); console.log(a / b); ```` ::: ## 숏코딩 풀이 주어진 숫자가 한자리수인 점을 이용 해 입력을 문자열로 처리하면 더 짧게 처리가 가능하다. :::boj-code PHP ```php <?=($_=fgets(STDIN))[0]/$_[2]; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 10998 : A×B (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/10998</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/10998</guid><description><![CDATA[ 백준 10998 : A×B 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-04T13:18:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 두 정수 A와 B를 입력받은 다음, A×B를 출력하는 프로그램을 작성하시오. ## 입력 첫째 줄에 A와 B가 주어진다. (0 〈 A, B 〈 10) ## 출력 첫째 줄에 A×B를 출력한다. :::boj-input 예제 입력 1 1 2 ::: :::boj-output 예제 출력 1 2 ::: :::boj-input 예제 입력 2 3 4 ::: :::boj-output 예제 출력 2 12 ::: ## 알고리즘 분류 - 수학 - 구현 - 사칙연산 --- ## 풀이 한줄로 입력된 두 숫자를 구하고 결과를 출력한다 :::boj-code PHP ```php <? fscanf(STDIN, "%d %d", $a, $b); echo $a * $b; ``` ::: :::boj-code CPP ```cpp #include <iostream> using namespace std; int main(){ int a, b; cin >> a >> b; cout << a * b; return 0; } ``` ::: :::boj-code JavaScript ```JavaScript const fs = require('fs'); const inputData = fs.readFileSync(0, 'utf8').toString().split(' '); const a = parseInt(inputData[0]), b = parseInt(inputData[1]); console.log(a * b); ``` ::: ## 숏코딩 풀이 `fscanf`는 결과를 할당할 변수를 인자로 넣어주지 않으면, 모든 결과를 배열로 반환한다 :::boj-code PHP ```php <? echo array_product(fscanf(STDIN, "%d%d")); ``` ::: 주어진 숫자가 한자리수인 점을 이용 해 입력을 문자열로 처리하면 더 짧게 처리가 가능하다. :::boj-code PHP ```php <?=($_=fgets(STDIN))[0]*$_[2]; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 1001 : A-B (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/1001</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/1001</guid><description><![CDATA[ 백준 1001 : A-B 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-04T13:14:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오. ## 입력 첫째 줄에 A와 B가 주어진다. (0 〈 A, B 〈 10) ## 출력 첫째 줄에 A-B를 출력한다. :::boj-input 예제 입력 3 2 ::: :::boj-output 예제 출력 1 ::: ## 알고리즘 분류 - 수학 - 구현 - 사칙연산 --- ## 풀이 한줄로 입력된 두 숫자를 구하고 결과를 출력한다 :::boj-code PHP ```php <? fscanf(STDIN, "%d %d", $a, $b); echo $a - $b; ``` ::: :::boj-code CPP ```cpp #include <iostream> using namespace std; int main(){ int a, b; cin >> a >> b; cout << a - b; return 0; } ``` ::: :::boj-code JavaScript ```JavaScript const fs = require('fs'); const inputData = fs.readFileSync(0, 'utf8').toString().split(' '); const a = parseInt(inputData[0]), b = parseInt(inputData[1]); console.log(a - b); ``` ::: ## 숏코딩 풀이 주어진 숫자가 한자리수인 점을 이용 해 입력을 문자열로 처리하면 더 짧게 처리가 가능하다. :::boj-code PHP ```php <?=($_=fgets(STDIN))[0]-$_[2]; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 1000 : A+B (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/1000</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/1000</guid><description><![CDATA[ 백준 1000 : A+B 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-04T13:11:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. ## 입력 첫째 줄에 A와 B가 주어진다. (0 〈 A, B 〈 10) ## 출력 첫째 줄에 A+B를 출력한다. :::boj-input 예제 입력 1 2 ::: :::boj-output 예제 출력 3 ::: ## 알고리즘 분류 - 수학 - 구현 - 사칙연산 --- ## 풀이 한줄로 입력된 두 숫자를 구하고 결과를 출력한다 :::boj-code PHP ```php <? fscanf(STDIN,"%d %d", $a, $b); echo $a + $b; ``` ::: :::boj-code CPP ```cpp #include <iostream> using namespace std; int main(){ int a, b; cin >> a >> b; cout << a + b; return 0; } ``` ::: :::boj-code JavaScript ```JavaScript const fs = require('fs'); const inputData = fs.readFileSync(0, 'utf8').toString().split(' '); const a = parseInt(inputData[0]), b = parseInt(inputData[1]); console.log(a + b); ``` ::: ## 숏코딩 풀이 `fscanf`는 결과를 할당할 변수를 인자로 넣어주지 않으면, 모든 결과를 배열로 반환한다 :::boj-code PHP ```php <? echo array_sum(fscanf(STDIN, "%d%d")); ``` ::: 주어진 숫자가 한자리수인 점을 이용 해 입력을 문자열로 처리하면 더 짧게 처리가 가능하다. :::boj-code PHP ```php <?=($_=fgets(STDIN))[0]+$_[2]; ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 🏅 백준 2557 : Hello World (C++, PHP, Javascript) ]]></title><link>https://present.kim/posts/baekjoon/2557</link><guid isPermaLink="false">https://present.kim/posts/baekjoon/2557</guid><description><![CDATA[ 백준 2557 : Hello World 문제를 C++, PHP, Javascript로 풀이한 내용입니다. ]]></description><pubDate>2022-11-04T12:55:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 Hello World!를 출력하시오. ## 입력 없음 ## 출력 Hello World!를 출력하시오. :::boj-input 예제 입력 ::: :::boj-output 예제 출력 Hello World! ::: ## 알고리즘 분류 - 구현 --- ## 풀이 단순히 Hello World! 를 출력하면 된다 :::boj-code PHP ```php <? echo "Hello World!"; ``` ::: :::boj-code CPP ```cpp #include <iostream> using namespace std; int main() { cout << "Hello World!"; return 0; } ``` ::: :::boj-code JavaScript ```JavaScript console.log("Hello World!"); ``` ::: ## 숏코딩 풀이 php는 `<?php ?>` 태그 밖의 문자는 그대로 출력하기 때문에 아래 코드도 정답으로 처리된다 :::boj-code PHP ```php Hello World! ## 숏코딩 풀이 php는 `<?php ?>` 태그 밖의 문자는 그대로 출력하기 때문에 아래 코드도 정답으로 처리된다 ``` ::: ]]></content:encoded></item><item><title><![CDATA[ 📝 블로그에 코드 블럭 하이라이팅이 추가되었습니다. ]]></title><link>https://present.kim/posts/blog/codeblock-prismjs</link><guid isPermaLink="false">https://present.kim/posts/blog/codeblock-prismjs</guid><description><![CDATA[ mdsvex의 prism.js를 테스트하기 위해 작성되었습니다 ]]></description><pubDate>2022-10-28T12:00:00.000Z</pubDate><content:encoded><![CDATA[ [mdsvex](https://mdsvex.com)는 기본적으로 [prism.js](https://prismjs.com)를 통해 코드 블럭의 하이라이팅을 지원합니다. 아래 내용은 코드 블럭 하이라이팅을 테스트하기 위해 작성되었습니다. --- > ### php > > ```php ><?php > echo "Hello World!"; > ?> > ``` > ### html > > ```html ><h1>Hello World!</h1> > ``` > ### css > > ```css > h1 { > color: red; > } > ``` > ### js > > ```js > console.log('Hello World!'); > ``` > ### json > > ```json > { > "name": "Hello World!" > } > ``` > ### bash > > ```bash > echo "Hello World!" > ``` > ### python > > ```python > print("Hello World!") > ``` > ### java > > ```java > public class HelloWorld { > public static void main(String[] args) { > System.out.println("Hello World!"); > } > } > ``` > ### c > > ```c > #include <stdio.h> > > int main() { > printf("Hello World!"); > return 0; > } > ``` > ### cpp > > ```cpp > #include <iostream> > > int main() { > std::cout << "Hello World!"; > return 0; > } > ``` > ### csharp > > ```csharp > using System; > > namespace HelloWorld { > class Program { > static void Main(string[] args) { > Console.WriteLine("Hello World!"); > } > } > } > ``` > ### go > > ```go > package main > > import "fmt" > > func main() { > fmt.Println("Hello World!") > } > ``` > ### kotlin > > ```kotlin > fun main() { > println("Hello World!") > } > ``` > ### swift > > ```swift > print("Hello World!") > ``` > ### ruby > > ```ruby > puts "Hello World!" > ``` > ### rust > > ```rust > fn main() { > println!("Hello World!"); > } > ``` > ### scala > > ```scala > object HelloWorld { > def main(args: Array[String]) { > println("Hello World!") > } > } > ``` > ### sql > > ```sql > SELECT * FROM table; > ``` > ### diff > > ```diff > - This is a red text > + This is a green text > ! This is an strong text > This is normal text > ``` ]]></content:encoded></item><item><title><![CDATA[ 📝 이제 MDsveX를 통해 포스트를 작성할 수 있습니다 ]]></title><link>https://present.kim/posts/blog/basic-markdown</link><guid isPermaLink="false">https://present.kim/posts/blog/basic-markdown</guid><description><![CDATA[ mdsvex를 통해 블로그의 포스트를 마크다운 파일로 작성합니다. 아래 내용은 마크다운의 기본 문법들을 테스트하기 위해 markdownguide.org의 basic-syntax를 인용했습니다. ]]></description><pubDate>2022-10-26T12:00:00.000Z</pubDate><content:encoded><![CDATA[ [mdsvex](https://mdsvex.com)를 통해 블로그의 포스트를 마크다운 파일로 작성합니다. 아래 내용은 마크다운의 기본 문법들을 테스트하기 위해 [markdownguide.org](https://markdownguide.org)의 [basic-syntax](https://www.markdownguide.org/basic-syntax/)를 인용했습니다. --- <h1 align="center" id="readme">The Complete Guide of <br> Readme Markdown Syntax</h1> Markdown is a syntax for styling all forms of writing on the GitHub platform. Mostly, it is just regular text with a few non-alphabetic characters thrown in, like `git # or * ` You can use Markdown most places around GitHub: 1. Gists 2. Comments in Issues and Pull Requests 3. Files with the .md or .markdown extension --- ### Headers ```markdown # Heading 1 ## Heading 2 ### Heading 3 #### Heading 4 ##### Heading 5 ###### Heading 6 ``` # Heading 1 ## Heading 2 ### Heading 3 #### Heading 4 ##### Heading 5 ###### Heading 6 --- ### Font ```markdown _Italics_ _This will also be italic_ **Bold text** **This will also be bold** **_Bold and Italics_** _You **can** combine them_ ~~Striked Text~~ **_~~Italic, bold, and strikethrough1~~_** ``` _Italics_ <br> _This will also be italic_<br> **Bold Text**<br> **This will also be bold**<br> **_Bold and Italics_**<br> _You **can** combine them_<br> ~~Striked Text~~<br> **_~~Italic, bold, and strikethrough1~~_** --- ### Lists > Unordered ```markdown - Item 1 - Item 2 - Item 1a - Item 2a - Item 1b - Item 2b ``` - Item 1 - Item 2 - Item 1a - Item 2a - Item 1b - Item 2b OR `- Item 1` - Item 1 > Ordered ```markdown 1. First 2. jhg 1. Second 2. jhg 1. Third 2. jhg ``` 1. First 2. jhg 1. Second 2. jhg 1. Third 2. jhg --- ### Links ```markdown - [Link with more info with various formatting options](https://docs.github.com/en/github/writing-on-github 'more info') - https://www.google.com/ - <https://www.google.com/> ``` - [Link with more info with various formatting options](https://docs.github.com/en/github/writing-on-github 'more info') - https://www.google.com/ - <https://www.google.com/> ### Link Label ```markdown [My GitHub][githublink] ``` [My GitHub][githublink] You may define your link label anywhere in the document. ```markdown e.g. put on bottom: --- [githublink]: https://github.com/PresentKim ``` ### Links to the URLs in a repository ```markdown [Example document](/posts/blog/basic-markdown) ``` [Example document](/posts/blog/basic-markdown) ```markdown [example](./basic-markdown) ``` [example](./basic-markdown) --- ### Inserting Images or Gifs using links ```markdown ![alt](URL 'title') ``` - alt in square bracket indicates the replacement text when the image fails to display (can be omitted) - parenthesis contains image source - title in quotes indicates the text to display when the mouse hovers over the image (can be omitted) Nite: Dropping the image to the readme file will upload it automatically with this syntax; It's the same as links, but add an exlamation mark (!) before opening square bracket; Image source can be either a location from the local machine or any valid image URL; > Example ```markdown ![Octocat](https://avatars.githubusercontent.com/u/13284800?v=4 'Profile') ``` ![Octocat](https://avatars.githubusercontent.com/u/13284800?v=4 'Profile') ### Resize images/Gifs ``` <img src="https://avatars.githubusercontent.com/u/13284800?v=4" alt="Profile" width="385px" align="center"> ``` <img src="https://avatars.githubusercontent.com/u/13284800?v=4" alt="Profile" width="42px" align="center"> You can use HTML tags like width="42px", hight="100px", align="center", etc depending what you need. In this case this gif was once uploaded to the repository and the link was taken from there. --- ### Linking Image/Gif To open another webpage when image is clicked, enclose the Markdown for the image in brackets, and then add the link in parentheses. ``` [![Octocat](https://avatars.githubusercontent.com/u/13284800?v=4 "GitHub Logo")](https://github.com/) ``` [![Octocat](https://avatars.githubusercontent.com/u/13284800?v=4 'GitHub Logo')](https://github.com/) --- ### Tables ```markdown | Header1 | Header2 | Header3 | | ------- | ------- | ------- | | This | is a | table | | This | is 2nd | row | | This | is 3rd | row | ``` | Header1 | Header2 | Header3 | | ------- | ------- | ------- | | This | is a | table | | This | is 2nd | row | | This | is 3rd | row | ### Align You may specify alignment like this: ```markdown | Align left | Centered | Align right | | :--------- | :-------------: | ----------: | | col 3 is | some wordy text | $1600 | ``` | Align left | Centered | Align right | | :--------- | :------: | ----------: | | aaa | bbb | ccc | p.s. You can use alignment with `<h1 (or 2 etc.) align="center"> your text </h1>` tags or with `<p align="center"> your text</p>` tag to align plain text. --- ### CheckBox ```markdown - [ ] Checkbox1 - [ ] Checkbox2 - [x] Checkbox selected ``` - [ ] Checkbox1 - [ ] Checkbox2 - [x] Checkbox selected You may use this syntax in GitHub's issue to check or uncheck the checkbox in real time without having to modify the original version of the issue. --- ### Quoting Text ```markdown > This is a block quoted text ``` > This is a block quoted text ### Multi-level blockquotes ``` > Asia >> China >>> Beijing >>>> Haidian >>>>> Tsinghua ``` #### Look like > Asia > > > China > > > > > Beijing > > > > > > > Haidian > > > > > > > > > Tsinghua - These are fenced code blocks --- ### Text highlighting ```markdown `linux` `ubuntu` ``` Using a pair of backquotes is suitable for making tags for articles `linux` `ubuntu` --- ### Horizontal Line ```markdown --- --- --- ``` All three will be rendered as: --- p.s. ```markdown <hr> works too ``` --- ### Break between lines ```markdown <br> ``` --- ### Multi-line text Use three backticks: ``` asd, sfd, wer! ``` This syntax can also be used for code highlighting --- ### Comments in Markdown ```markdown  ``` They will be invisible on readme  --- ### Emoji ```markdown :grinning: or just place the emoji 😀 ``` :grinning: or just place the emoji 😀 To see a list of every image Github supports, check out the [Emoji Cheat Sheet](https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md) --- ### Code Block [See example](./codeblock-prismjs) --- ### Anchor In fact, each title is an anchor, similar to the HTML anchor (`#`), e.g. | Syntax | Look like | | ------------------------ | ---------------------- | | `[Back to top](#readme)` | [Back to top](#readme) | Note that all the letters in the title are converted to **lowercase letters**. [githublink]: https://github.com/PresentKim ]]></content:encoded></item><item><title><![CDATA[ ]]></title><link>https://present.kim/posts/samsung-codetest/protein-cpp</link><guid isPermaLink="false">https://present.kim/posts/samsung-codetest/protein-cpp</guid><description><![CDATA[ ]]></description><pubDate>2000-01-01T00:00:00.000Z</pubDate><content:encoded><![CDATA[ ## 문제 자신의 몸이 허약하다고 생각한 정택은 강해지기위해 운동을 하기 시작했다. 알고리즘 피트니스 센터의 센터장인 종민의 조언에 따라 “먹는 것 까지 운동이다.” 라는 철칙을 잘 따르고 있다. 전날 무리하게 운동한 여파로 늦잠을 자게되어, 오늘 먹을 단백질 도시락을 챙길 여유가 없었다. 어제 무리하게 운동한 것이 아까운 정택은 사무실 근처에 있는 편의점을 돌며 얻을 수 있는 최대의 단백질을 확보하려고 한다. 같은 단백질 함양을 가진 제품은 동일한 제품이고, 같은 도시락을 여러 번 먹으면 질리기때문에 서로 다른 제품을 통해 단백질을 섭취하고자 한다. 힘이 상승하고자하는 정택은 편의점을 ‘+’ 모양으로 순회하려고 한다. ![protein1.png](protein_01.jpg) ![protein2.png](protein_02.jpg) 위와 같이 편의점 정보가 존재한다고 했을 때, 각 칸에 해당하는 숫자는 해당 편의점에서 얻을 수 있는 단백질의 g 수 이다. 첫 번째 그림에서 얻을 수 있는 서로 다른 종류의 단백질 도시락 개수는 4개이며, 얻을 수 있는 단백질 g 수는 7+2+10+9 로 28 이다. 두 번째 그림에서 얻을 수 있는 서로 다른 종류의 단백질 도시락 개수는 5개이며, 얻을 수 있는 단백질 g 수는 1+3+4+9+10 로 27 이다. 순회 경로의 경우 만약 중앙을 기점으로 봤을 때, 상하좌우 경로의 길이를 서로 달리할 수 있다. 이때 경로의 길이 최솟값은 상하좌우 각각 모두 1로 고정한다. 즉, 하나의 편의점만 들를 수 없고, 직선 형태, 'ㄱ', 'ㄴ' 등의 모양으로 순회를 할 수 없다는 것이다. 예를 들면, 다음과 같이 다양하게 존재할 수 있다. ![protein3.png](protein_03.jpg) ![protein4.png](protein_04.jpg) ![protein5.png](protein_05.jpg) ![protein6.png](protein_06.jpg) ![protein7.png](protein_07.jpg) 시작 지점에서 출발하여 다시 시작 지점으로 돌아온다고 했을 때, N \* N 의 편의점 단백질 도시락 정보에서 가장 많이 얻을 수 있는 단백질 함량의 합을 구해보자. 편의점 정보가 주어졌을 때, 답을 구하는 과정은 다음과 같다. (총 6가지가 존재하는 것은 아니며, 몇 가지 경우는 생략되었다.) ![protein8.png](protein_08.jpg) ![protein9.png](protein_09.jpg) ![protein10.png](protein_10.jpg) ![protein11.png](protein_11.jpg) ![protein12.png](protein_12.jpg) ![protein13.png](protein_13.jpg) 마지막 그림에서 얻어지는 숫자의 합 1+2+3+5+6+7+8 인 32 가 정답이다. ## 입력 첫 번째 줄에 테스트 케이스의 개수 T(5 ≤ T ≤ 50) 가 주어진다. 각 테스트 케이스의 첫째 줄에 N(3 ≤ N ≤ 20) 이 주어지고, N 개의 줄에 걸쳐 N 개의 숫자가 공백을 통해 구분하여 입력된다. 각각의 입력되는 숫자는 1 부터 100 을 포함한 정수이다. ## 출력 각 테스트 케이스에 해당하는 결과값을 한 줄에 하나씩 “#t result” 포맷으로 출력한다. (t는 1부터 T까지의 정수이다) ```예제_입력 5 4 7 8 6 10 9 2 7 1 6 5 1 3 1 7 5 9 10 7 7 5 8 3 1 5 6 4 4 1 8 4 4 4 6 3 7 9 3 8 8 6 7 3 8 5 4 3 7 3 4 1 6 4 3 5 3 2 7 9 9 1 8 3 9 6 4 2 2 4 5 5 7 4 7 1 8 9 6 1 7 7 8 5 2 6 1 5 2 3 9 6 1 8 2 3 4 5 4 2 1 1 2 9 6 1 4 6 6 9 2 4 6 7 1 4 3 8 6 8 4 7 1 6 8 5 8 7 4 5 6 1 9 1 1 8 7 2 1 4 1 7 1 1 3 8 6 2 5 2 5 1 9 8 8 4 8 7 8 9 1 2 2 4 3 3 9 4 3 9 3 2 2 8 5 9 4 3 4 2 3 4 6 6 6 5 3 9 3 7 5 9 4 9 1 5 4 3 3 7 8 1 6 6 8 7 3 3 3 1 3 9 8 5 6 1 1 3 7 6 3 4 7 7 3 6 1 3 2 1 9 6 1 8 2 2 2 2 ``` ```예제_출력 #1 32 #2 45 #3 45 #4 39 #5 36 ``` ## 제한 사항 - 제한시간 : 3초 --- ## 풀이 문제에서 제시된 조건을 정리해보면 아래와 같다. 1. `같은 단백질 함양을 가진 제품은 동일한 제품이고, 같은 도시락을 여러 번 먹으면 질리기때문에 서로 다른 제품을 통해 단백질을 섭취하고자 한다.` - 선택된 편의점(칸)의 단백질 함양(값) 중 같은 것은 제외하고 합산해야 한다. 2. `정택은 편의점을 ‘+’ 모양으로 순회하려고 한다.` - 따라서 첫 줄과 마지막 줄은 제외한 후 순회해야 한다. 제한시간이 3초로 여유로운 편이기 때문에 전체 순회를 시도해도 될 것 같다. 가능한 모든 경우의 수를 순회해 가장 큰 값을 찾아 해결했다. 3. `정택은 사무실 근처에 있는 편의점을 돌며 얻을 수 있는 최대의 단백질을 확보하려고 한다.` - 최대의 단백질을 확보해야 하므로 가장 큰 값을 찾아야 한다. ```cpp #include <iostream> using namespace std; //중복을 제외한 모든 값의 합을 구하는 함수 int uniqueSum(int arr[], int length){ int temp[length]; //중복을 제외한 값들을 저장할 배열 int count = 0; //중복을 제외한 값의 개수(인덱스용) int sum = 0; //중복을 제외한 값들의 합 bool isNew; //중복 여부를 판단하는 변수 for(int i = 0; i < length; ++i){ //배열의 모든 값을 순회 isNew = true; //중복을 제외한 값들의 배열을 순회하며 중복 여부를 판단 for(int j = 0; j < count; ++j){ if(temp[j] == arr[i]){ isNew = false; break; } } if(isNew){ //중복이 아니라면 temp[count++] = arr[i]; //중복을 제외한 값들의 배열에 추가 sum += arr[i]; //중복을 제외한 값들의 합에 추가 } } return sum; } int test(){ //테스트 케이스의 가로 세로 길이(N) 입력 받기 int n; cin >> n; //테스트 케이스의 편의점 정보 입력 받기 int arr[n][n]; for(int i = 0; i < n; ++i){ for(int j = 0; j < n; ++j){ cin >> arr[j][i]; } } //테스트 케이스의 편의점 정보를 순회하며 최대의 단백질 함양을 구하기 int temp[n + n], current, max = -1; for(int i = 1; i < n - 1; ++i){ //첫 줄과 마지막 줄은 제외 for(int j = 1; j < n - 1; ++j){ //첫 줄과 마지막 줄은 제외 for(int k = 0; k < n; ++k){ //가로 세로 방향 순회를 한번에 진행하고 temp 변수에 입력 temp[k] = arr[i][k]; temp[k + n] = arr[k][j]; } current = uniqueSum(temp, n + n); //중복을 제외한 모든 값의 합을 구함 if(max < current){ max = current; //최대값을 갱신 } } } return max; } int main() { //테스트 케이스의 수(T) 입력 받기 int t; cin >> t; //테스트 케이스의 수만큼 테스트를 반복 for(int i = 0; i < t; ++i){ cout << "#" << (i + 1) << " " << test() << endl; } return 0; } ``` ]]></content:encoded></item></channel></rss>